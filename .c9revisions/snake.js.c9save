{"ts":1341116535488,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"(function main()\n{\n    //\"use strict\";\n    var LEFT_KEY_CODE=37;\n    var UP_KEY_CODE=38;\n    var RIGHT_KEY_CODE=39;\n    var DOWN_KEY_CODE=40;\n    var ESCAPE_KEY_CODE=27;\n    var SPACE_KEY_CODE=32;//TO PAUSE THE GAME\n\n    var NO_OF_INITIAL_BODY_PARTS=20;\n    var POSITIVE_90_ROTATION=\"rotate(90deg)\";\n    var NEGATIVE_90_ROTATION=\"rotate(-90deg)\";\n    var NEGATIVE_180_ROTATION=\"rotate(-180deg)\";\n    var ZERO_ROTATION=\"\";\n    var BODY_PART_SIZE=20;\n    var SPEED=70;\n    var INCREASE_SIZE_BY=4;\n    var GULP_COUNTER_DIV_ID='snake_gulp_counter';\n    var GULP_COUNTER_DIV_CLASS='counter';\n    var LAST_BODY_PART_SELECTOR='#snake span:nth-last-child(1)';\n    var SNAKE_FIGURE='<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"><rect class=\"snake_figure\" id=\"snake_figure\" width=\"'+BODY_PART_SIZE+'\" height=\"'+BODY_PART_SIZE+'\"/></svg>';\n    var SNAKE_BODY_PART_CLASS='snake_body_part';\n    var SNAKE_BODY_PART_ID='snake_body_part';\n    var body=document.body;\n /*    var LIST_OF_ELEMENTS=[\n     'body'   \n    ]//A list of those elements whose style will be saved and restored;We will be modifyin only the internal style.\n */  \n    var snake=window.snake={};//Snake Namespace    \n    var point=snake.point={};//Holds the position of the point.\n    var orig_layout=snake.orig_layout={}//It will hold the original style information for the page\n    var key_queue=snake.key_queue=[];//Holds the keys to be processed\n    var isDestroyed=snake.isDestroyed=false;\n    var window_availWidth=-1;\n    var window_availHeight=-1;\n\n    (function(){\n    var screen_height=screen.height;\n    var screen_width=screen.width;\n    var body_height=document.body.clientHeight;\n    var body_width=document.body.clientWidth;\n    var docel_height=document.documentElement.clientHeight;\n    var docel_width=document.documentElement.clientWidth;\n    var maxh=Math.max(body_height,docel_height);\n    var maxw=Math.max(body_width,docel_width);\n    var minh=Math.min(body_height,docel_height);\n    var minw=Math.min(body_width,docel_width);\n    if(maxh>screen_height)\n    window_availHeight=minh;\n    else\n    window_availHeight=maxh;\n    \n    if(maxw>screen_width)\n    window_availWidth=minw;\n    else\n    window_availWidth=maxw;\n    \n    })();\n    \n    \n    //Adjust the size of snake playground according to the available size of page and integral multiple of the movement made by snake\n    var width=snake.width=Math.floor(window_availWidth-(window_availWidth%BODY_PART_SIZE));\n    var height=snake.height=Math.floor(window_availHeight-(window_availHeight%BODY_PART_SIZE));\n\n    function getIntegerPartFromString(str)\n    {\n        return parseInt(str,10);\n    }\n    function createSnakeElement(props)\n    {\n        var el=document.createElement(props.tagName);\n        \n        if(props.className)\n        el.setAttribute('class',props.className);\n        \n        if(props.id)\n        el.setAttribute('id',props.id);\n        \n        if(props.innerHTML)\n        el.innerHTML=props.innerHTML;        \n        \n        if(props.style)\n        {\n        if(!(typeof props.style.left == \"undefined\"))\n        el.style.left=props.style.left+\"px\";\n        \n        if(!(typeof props.style.top == \"undefined\"))\n        el.style.top=props.style.top+\"px\";\n        \n        if(!(typeof props.style.height == \"undefined\"))\n        el.style.height=props.style.height+\"px\";\n        \n        if(!(typeof props.style.width == \"undefined\"))\n        el.style.width=props.style.width+\"px\";\n        }\n        el.appendChildWithInformation=appendChildWithInformation;\n                \n        \n        return el;\n    }\n    \n    var snake_playground=createSnakeElement({\n        tagName:'div',\n        className:'snake_playground',\n        id:'snake_playground',\n        style:{\n            height:height,\n            width:width\n                }\n        });//Its the root element for the snake game\n    \n    \n    function appendChildWithInformation(child){\n    var el=createSnakeElement(child);\n    this.appendChild(el);\n    return el;\n    }\n    \n\n    var snake_body=snake_playground.appendChildWithInformation({\n        tagName:'div',\n        className:'snake',\n        id:'snake',\n        style:{\n                height:height,\n                width:width\n              }\n        });\n\n    \n    \n    var gulp_counter_el=snake_playground.appendChildWithInformation({tagName:'div',\n              className:GULP_COUNTER_DIV_CLASS,\n              id:GULP_COUNTER_DIV_ID,\n              innerHTML:'0'\n             });\n             \n    var state_of_game_el=snake_playground.appendChildWithInformation({tagName:'div',\n             className:'snake_state',\n             id:'snake_state',\n             innerHTML:'PAUSED'\n    });\n    \n    //Finally append the snake playground to the body.\n    body.appendChild(snake_playground);\n\n    \n    function restart_game()\n    {\n        kill_game();\n        main(); \n    }\n    \n    function mark_point()\n    {\n         var x=(Math.random())*(getIntegerPartFromString(snake_playground.style.width));\n         var y=(Math.random())*(getIntegerPartFromString(snake_playground.style.height));\n         x=Math.ceil(x);\n         y=Math.ceil(y);\n\n         //Hnandle the case when random no is 1\n         x-=BODY_PART_SIZE;\n         y-=BODY_PART_SIZE;\n         \n         x=x-(x%BODY_PART_SIZE);\n         y=y-(y%BODY_PART_SIZE);\n         point.el=snake_playground.appendChildWithInformation({\n             tagName:'div',\n             className:'snake_point',\n             id:'snake_point',\n             innerHTML:SNAKE_FIGURE,\n             style:{\n                    left:x,\n                    top:y\n                    }\n             });\n         \n         //Store the position of the point in snake namespace for easy accessibilty\n         point.x=x;\n         point.y=y;\n        }\n    \n    function add_to_queue(keyCode)\n    {\n        //FOR NOW ONLY THE LAST ELEMENT of QUEUE IS CONSIDERED\n        if(key_queue.length==1)\n        {\n         key_queue.shift();\n        }\n        \n        key_queue.push(keyCode);\n    }\n    function keypress_listener(e)\n    {\n        if(e.keyCode==LEFT_KEY_CODE ||e.keyCode==DOWN_KEY_CODE ||e.keyCode==UP_KEY_CODE ||e.keyCode==RIGHT_KEY_CODE )\n        {\n         e.preventDefault();\n         e.stopPropagation();\n         if(!isDestroyed)\n          add_to_queue(e.keyCode);\n         else\n         alert('Game has already ended')\n        }\n        else \n        {\n         if(e.keyCode==ESCAPE_KEY_CODE)\n         {\n            if(isDestroyed)\n            return;\n            e.preventDefault();\n            e.stopPropagation();\n            kill_game();\n         }\n         else if(e.keyCode==SPACE_KEY_CODE)\n         {\n             e.preventDefault();\n             e.stopPropagation();              \n              if(snake.paused===true)\n              resume();\n              else\n              pause();\n              \n              snake.paused=toggle(snake.paused);\n         }\n        }\n        \n    }\n    function toggle(boolvar)\n    {\n     if(typeof boolvar !='boolean')\n     {\n         throw new Error('boolvar is not a bool');\n     }\n     if(boolvar===true)\n     boolvar=false;\n     else\n     boolvar=true;\n     return boolvar;\n    }\n    \n    function kill_game() \n    {\n        stop();\n        try\n        {\n         if(snake_playground)\n         {\n          body.removeChild(snake_playground);\n         }\n        }\n        catch(e)\n        {\n          console.log('Exception:',\"Caller is =\"+kill_game.caller,\"ParentNode=\"+snake_playground.parentNode,\"Node=\"+snake_playground);\n        }\n        RestoreLayout();\n    }\n    \n    function check_for_overlap(el)\n    {\n      //TODO:copy childnodes to an array cause domenodes processing is costly\n      var last=body.querySelector(LAST_BODY_PART_SELECTOR);\n      var last_style=last.style;\n      var last_style_top=last_style.top;\n      var last_style_left=last_style.left;\n      var len=el.childNodes.length;\n      for(var i=0;i<len-1;i++)\n      {\n       var child=el.childNodes[i];\n       var child_style=child.style;\n       var top=child_style.top;\n       var left=child_style.left;\n       if((top==last_style_top) && (left==last_style_left))\n       snake_crashed_into_wall();\n      }        \n    }\n    \n    function check_for_up_crash(last_style)\n    {\n        if((getIntegerPartFromString(last_style.top))<0)\n        snake_crashed_into_wall();\n    }\n    function check_for_left_crash(last_style)\n    {\n        if((getIntegerPartFromString(last_style.left))<0)\n        snake_crashed_into_wall();\n    }\n    function check_for_right_crash(last_style,offset)\n    {\n       if((getIntegerPartFromString(last_style.left)+offset)>window_availWidth)\n                snake_crashed_into_wall();            \n    }\n   function check_for_down_crash(last_style,offset)\n   {\n          if((getIntegerPartFromString(last_style.top)+offset)>window_availHeight)\n            snake_crashed_into_wall();    \n   }\n\n    function process_keypress(el,keyCode)\n    {\n        var no_of_child_nodes=el.childNodes.length;\n        var rotation={};\n        rotation.value=el.childNodes[(no_of_child_nodes-1)].rotation;\n        el.childNodes[no_of_child_nodes-1].rotation=rotation.value=(typeof rotation.value==\"undefined\")?ZERO_ROTATION:rotation.value;\n        rotation.isNeg90=(rotation.value==NEGATIVE_90_ROTATION );\n        rotation.isPos90=(rotation.value==POSITIVE_90_ROTATION );\n        rotation.isNeg180=(rotation.value==NEGATIVE_180_ROTATION );\n        rotation.isZero=(rotation.value==ZERO_ROTATION );\n        \n        var move_distance=BODY_PART_SIZE;\n        var last=document.body.querySelector(LAST_BODY_PART_SELECTOR);\n        var last_style=last.style;\n        var offset=BODY_PART_SIZE;        \n        var isItTheExpectedKey=true;\n        switch(keyCode)\n        {\n            case LEFT_KEY_CODE:\n            if(rotation.isNeg90 || rotation.isPos90 || rotation.isNeg180)\n            {\n                process_left_key(el,move_distance);\n                check_for_left_crash(last_style);\n            }\n            break;\n            \n            case UP_KEY_CODE:\n            if(rotation.isNeg90 ||rotation.isZero || rotation.isNeg180)\n            {\n                process_up_key(el,move_distance);\n                check_for_up_crash(last_style);            \n            }\n            break;\n            \n            case RIGHT_KEY_CODE:\n            if(rotation.isPos90 || rotation.isZero || rotation.isNeg90)\n            {\n                process_right_key(el,move_distance);\n                check_for_right_crash(last_style,offset);      \n            }\n            break;\n\n            case DOWN_KEY_CODE:\n            if(rotation.isPos90 || rotation.isZero || rotation.isNeg180)\n            {\n                process_down_key(el,move_distance)\n                check_for_down_crash(last_style,offset);\n            }\n            break;\n            \n            default:\n            isItTheExpectedKey=false;\n            alert('Unexpected key');\n       }\n       if(isItTheExpectedKey)\n       {\n           try_to_gulp(el);\n       }\n   }\n   \n    function try_to_gulp(el)\n    {\n      var last=body.querySelector(LAST_BODY_PART_SELECTOR);\n      var last_style=last.style;\n      var last_style_top=last_style.top;\n      var last_style_left=last_style.left;\n      if(((snake.point.x+\"px\")==last_style_left) && ((snake.point.y+\"px\")==last_style_top))\n      {\n          snake_playground.removeChild(point.el);\n          gulp(el,true);\n          mark_point();\n      }      \n    }\n    function gulp(el,consume)\n    {\n        if((typeof gulp.id) == \"undefined\")\n        gulp.id=0;\n        if((typeof gulp.count) == \"undefined\")\n        gulp.count=0;\n        if(consume===true)\n        {\n         for(var i=0;i<INCREASE_SIZE_BY;i++)\n         {         \n          gulp.id+=1;\n          \n          var offsetx=0;\n          var offsety=0;\n          var firstChild=el.childNodes[0];\n          var firstChild_style=firstChild.style;\n          var left=getIntegerPartFromString(firstChild_style.left);\n          var top=getIntegerPartFromString(firstChild_style.top);\n          var rotation=firstChild.rotation;\n          \n          \n          //The insertion philosophy is opposite to usual\n          if(rotation==NEGATIVE_180_ROTATION)\n          offsetx=BODY_PART_SIZE;\n          else if(rotation==ZERO_ROTATION)\n          offsetx=-BODY_PART_SIZE;\n          else if(rotation==POSITIVE_90_ROTATION)\n          offsety=-BODY_PART_SIZE;\n          else if(rotation==NEGATIVE_90_ROTATION)\n          offsety=BODY_PART_SIZE;\n         \n          if((offsetx===0) && (offsety===0))\n          console.log(\"RAISE EXCEPTION HERE\");\n         \n          var span=createSnakeElement({\n                tagName:'span',\n                className:SNAKE_BODY_PART_CLASS,\n                id:SNAKE_BODY_PART_ID+gulp.id,\n                innerHTML:SNAKE_FIGURE,\n                style:{\n                       left:left+offsetx,\n                       top:top+offsety\n                      }\n                });\n          span.rotation=rotation;\n\n          el.insertBefore(span,el.childNodes[0]);\n         }\n         gulp.count+=1;\n         gulp_counter_el.innerHTML=gulp.count;\n        }\n        else\n        {\n            gulp.id+=1;\n            el.appendChildWithInformation({\n                tagName:'span',\n                className:SNAKE_BODY_PART_CLASS,\n                id:SNAKE_BODY_PART_ID+gulp.id,\n                innerHTML:SNAKE_FIGURE,\n                style:{\n                       left:0,\n                       top:0\n                      }\n                });\n        }\n        \n    }\n    \n    function snake_crashed_into_wall()\n    {\n          if(isDestroyed)\n          {\n           alert('Already destroyed-snake_crashed_into_wall.Caller is'+snake_crashed_into_wall.caller);\n           return;\n          }\n          isDestroyed=true;\n          //kill_game();\n          var response=confirm(\"Game Over.\\nRestart the Game ?\");          \n          if(response)\n          restart_game();\n          else\n          kill_game();\n    }\n    \n    function process_general(element,distance,leave_last)\n    {    \n        //TODO: make a copy of node list as traversing it is costly.\n        var len=element.childNodes.length;\n        var up_to=len;\n    \n        if(leave_last)\n        up_to=len-1;\n        \n        for(var i=0;i<up_to;i++)\n        {\n         var child=element.childNodes[i];\n         var child_style=child.style;\n         \n         child.rotation=((typeof child.rotation)==\"undefined\")?ZERO_ROTATION:child.rotation;\n         var rotation=child.rotation;\n         \n         var rotation_flag=false;\n         if(child.rotation==POSITIVE_90_ROTATION || child.rotation==NEGATIVE_90_ROTATION)\n         rotation_flag=true;\n         var lookahead_rotation_flag=-1;\n         var left_coordinate=getIntegerPartFromString(child_style.left);\n         var top_coordinate=getIntegerPartFromString(child_style.top);\n\n         if(i+1<len)\n         {\n              if(element.childNodes[i+1].rotation==POSITIVE_90_ROTATION || element.childNodes[i+1].rotation==NEGATIVE_90_ROTATION)\n              lookahead_rotation_flag=true;\n              if(element.childNodes[i+1].rotation==ZERO_ROTATION || element.childNodes[i+1].rotation==NEGATIVE_180_ROTATION)\n              lookahead_rotation_flag=false;\n         }\n         \n         \n         if(((typeof rotation_flag)===\"undefined\") ||  (rotation_flag===false))\n         {\n             child.isRotated=false;\n          \n            if(((typeof lookahead_rotation_flag)!==\"undefined\") && (lookahead_rotation_flag===true))\n            {\n             child.isRotated=true; \n             child.rotation=element.childNodes[i+1].rotation;\n             //Simulate rotation\n             if(child.rotation == NEGATIVE_90_ROTATION)\n             child_style.top=(top_coordinate-(distance))+\"px\";\n             if(child.rotation == POSITIVE_90_ROTATION)\n             child_style.top=(top_coordinate+(distance))+\"px\";\n            }\n            else\n            {\n                   if(rotation==ZERO_ROTATION)\n                child_style.left=(left_coordinate+(distance))+\"px\";\n             else if(rotation==NEGATIVE_180_ROTATION)\n                child_style.left=(left_coordinate-(distance))+\"px\";\n            }\n            \n         }\n         else //rotation flag is true\n         {\n            if(((typeof lookahead_rotation_flag)===\"undefined\") || (lookahead_rotation_flag===false))\n            {\n             child.isRotated=false; \n             child.rotation=element.childNodes[i+1].rotation;\n              //Simulate rotation\n              if(child.rotation == ZERO_ROTATION)\n             child_style.left=(left_coordinate+(distance))+\"px\";\n             if(child.rotation == NEGATIVE_180_ROTATION)\n             child_style.left=(left_coordinate-(distance))+\"px\";\n             \n            }\n            else\n            {\n                 if(rotation==NEGATIVE_90_ROTATION)\n                child_style.top=(top_coordinate-(distance))+'px';\n                else if(rotation==POSITIVE_90_ROTATION)\n                child_style.top=(top_coordinate+(distance))+'px';\n                \n            }\n         }\n         \n        }\n    }\n\n    function process_down_key(element,distance)\n    {\n         var children=element.childNodes;\n         var key=children.length-1;\n         var rotation=children[key].rotation;\n         var child_style=children[key].style;\n         var top_coordinate=getIntegerPartFromString(child_style.top);\n         var leave_last=false;\n         if((rotation==ZERO_ROTATION) || (rotation==NEGATIVE_180_ROTATION))\n         {\n            leave_last=true;\n            process_general(element,distance,leave_last);\n            child_style.top=(top_coordinate+(distance))+\"px\";\n            element.childNodes[key].rotation=POSITIVE_90_ROTATION;\n         }       \n    }\n    \n    function process_up_key(element,distance){\n         \n         var children=element.childNodes;\n         var key=children.length-1;\n         var rotation=children[key].rotation;\n         var child_style=children[key].style;\n         var top_coordinate=getIntegerPartFromString(child_style.top);\n         var leave_last=false;\n         \n         if((rotation==ZERO_ROTATION) || (rotation==NEGATIVE_180_ROTATION))\n         {\n          leave_last=true;\n          process_general(element,distance,leave_last);\n          child_style.top=(top_coordinate-(distance))+\"px\";\n          element.childNodes[key].rotation=NEGATIVE_90_ROTATION;\n         }\n    }\n    \n        \n        function process_right_key(element,distance){\n         var children=element.childNodes;\n         var key=children.length-1;\n         var rotation=children[key].rotation;\n         var child_style=children[key].style;\n         var left_coordinate=getIntegerPartFromString(child_style.left);\n         var leave_last=false;\n         \n         if((rotation==POSITIVE_90_ROTATION) || (rotation==NEGATIVE_90_ROTATION))\n         {\n          leave_last=true;\n          process_general(element,distance,leave_last);\n          child_style.left=(left_coordinate+(distance))+\"px\";\n          element.childNodes[key].rotation=ZERO_ROTATION;\n         }\n      \n    }\n        function process_left_key(element,distance){\n        var children=element.childNodes;\n        var key=children.length-1;\n        var rotation=children[key].rotation;\n        var child_style=children[key].style;\n        var left_coordinate=getIntegerPartFromString(child_style.left);\n        var leave_last=false;\n         \n        if((rotation==POSITIVE_90_ROTATION) || (rotation==NEGATIVE_90_ROTATION))\n        {\n          leave_last=true;\n          process_general(element,distance,leave_last);\n          child_style.left=(left_coordinate-(distance))+\"px\";\n          element.childNodes[key].rotation=NEGATIVE_180_ROTATION;\n         }\n      \n    }\n    function simulate_snake(el)\n    {\n      var queue=key_queue;\n      var len=queue.length;\n      \n      if(len===0)\n      {\n        process_general(el,BODY_PART_SIZE);\n        \n        //Not pressing any key means snake is moving in direction of last body_part\n        var last=body.querySelector(LAST_BODY_PART_SELECTOR);\n        var rotation=last.rotation;\n        var last_style=last.style;\n       // console.log(\"STYLE\",last_style)\n        var offset=BODY_PART_SIZE;//Need to adjust it\n        if(rotation==NEGATIVE_180_ROTATION)\n         {\n             check_for_left_crash(last_style);\n         }\n         else if(rotation==ZERO_ROTATION)\n         {\n          check_for_right_crash(last_style,offset);\n         }\n         else if(rotation==POSITIVE_90_ROTATION)\n         {\n             check_for_down_crash(last_style,offset);\n         }\n         else if(rotation==NEGATIVE_90_ROTATION)\n         {\n             check_for_up_crash(last_style);\n         }\n         if(isDestroyed)\n         return;\n         check_for_overlap(el);\n         try_to_gulp(el);\n      }\n      else\n      {\n       process_keypress(el,queue.pop());\n      }\n    }\n    \n    function make_initial_snake(el)\n    {\n     for(var i=0;i<NO_OF_INITIAL_BODY_PARTS;i++)\n     {\n        gulp(el);\n        if(i>=1 && (i< NO_OF_INITIAL_BODY_PARTS))\n        {\n         el.childNodes[i].style.left=(getIntegerPartFromString(el.childNodes[i].style.left)+(i*BODY_PART_SIZE))+\"px\";\n        }\n     }\n     snake.paused=true;\n    }\n    function copy_style(el,save_obj)\n    {\n        var style=el.style;\n        var obj_style={};\n        \n        if(!save_obj.style)\n        obj_style=save_obj.style={};\n        else\n        obj_style=save_obj.style;\n        \n        for(var i in style)\n        {\n            obj_style[i]=style[i];\n        }\n    }\n    //Save the current style info in case something wrong happens or fore restoration\n    function SaveCurrentLayoutInfo()\n    {\n      var b=snake.orig_layout.body={};\n      b.style={};\n      b.style.overflow=body.style.overflow;\n      b.style.margin=body.style.margin;\n      //copy_style(body,snake.orig_layout.body);\n    }\n    \n    function ModifyCurrentLayout()\n    {\n        body.style.overflow=\"hidden\";\n        body.style.margin=\"0\";\n    }\n    \n    function RestoreLayout()\n    {\n      var b=snake.orig_layout.body;\n      body.style.overflow=b.style.overflow;\n      body.style.margin=b.style.margin;\n        //copy_style(snake.orig_layout.body,body.style);\n        \n    }\n    \n    function start(el)\n    {\n     SaveCurrentLayoutInfo();    \n     ModifyCurrentLayout();\n     addKeyListener();\n     make_initial_snake(el);\n     mark_point();\n    }\n    function stop()\n    {\n     clearInterval(snake.interval);    \n     removeKeyListener();\n    }\n    function pause()\n    {\n     state_of_game_el.innerHTML=\"PAUSED\";    \n     clearInterval(snake.interval);   \n    }\n    function resume()\n    {\n        state_of_game_el.innerHTML=\"\";\n        snake.interval=setInterval(function(){simulate_snake(snake_body);},SPEED);\n    }\n    function addKeyListener()\n    {\n     document.addEventListener(\"keydown\",keypress_listener,true);\n    }\n    function removeKeyListener()\n    {\n     document.removeEventListener(\"keydown\",keypress_listener,true);\n    }\n    start(snake_body);    \n})();\n"]],"start1":0,"start2":0,"length1":0,"length2":23014}]],"length":23014}
{"contributors":[],"silentsave":false,"ts":1341116666636,"patch":[[{"diffs":[[0,"  })();\n"],[-1,"    "],[0,"\n    \n  "]],"start1":2210,"start2":2210,"length1":20,"length2":16},{"diffs":[[0,"SIZE));\n"],[1,"console.log(window_availWidth,width)    "],[0,"\n    fun"]],"start1":2538,"start2":2538,"length1":16,"length2":56}]],"length":23050,"saved":false}
{"ts":1341117027665,"patch":[[{"diffs":[[0,"ole.log("],[-1,"window_availWidth"],[1,"document.documentElement.clientWidth,document.body.clientWidth,screen.width,\":\""],[0,",width) "]],"start1":2550,"start2":2550,"length1":33,"length2":95}]],"length":23112,"saved":false}
{"ts":1341117286514,"patch":[[{"diffs":[[0,"   \n"],[-1,"    })();\n\n"],[0,"    "]],"start1":2204,"start2":2204,"length1":19,"length2":8},{"diffs":[[0,"));\n"],[-1,"console.log(document.documentElement.clientWidth,document.body.clientWidth,screen.width,\":\",width)    "],[1,"    \n    })();\n"],[0,"\n   "]],"start1":2531,"start2":2531,"length1":110,"length2":23}]],"length":23014,"saved":false}
{"ts":1341117365920,"patch":[[{"diffs":[[0,"Width=-1"],[-1,";\n    var "],[1,","],[0,"window_a"]],"start1":1478,"start2":1478,"length1":26,"length2":17},{"diffs":[[0,"t=-1"],[1,",width=-1,height=-1"],[0,";\n"],[-1,"\n"],[0,"    "],[-1,"("],[0,"function"],[1," setDimensionsForPlayground"],[0,"(){\n"]],"start1":1504,"start2":1504,"length1":24,"length2":68},{"diffs":[[0,"    "],[-1,"var width="],[0,"snak"]],"start1":2382,"start2":2382,"length1":18,"length2":8},{"diffs":[[0,"    "],[-1,"var height="],[0,"snak"]],"start1":2464,"start2":2464,"length1":19,"length2":8},{"diffs":[[0,"  \n    }"],[-1,")();"],[0,"\n\n    fu"]],"start1":2551,"start2":2551,"length1":20,"length2":16}]],"length":23024,"saved":false}
{"ts":1341117381665,"patch":[[{"diffs":[[0,"oyed=false;\n"],[1,"    \n"],[0,"    var wind"]],"start1":1446,"start2":1446,"length1":24,"length2":29},{"diffs":[[0,",height=-1;\n"],[1,"    \n"],[0,"    function"]],"start1":1522,"start2":1522,"length1":24,"length2":29}]],"length":23034,"saved":false}
{"ts":1341117406010,"patch":[[{"diffs":[[0,"  {\n      var b="],[-1,"snake."],[0,"orig_layout.body"]],"start1":21681,"start2":21681,"length1":38,"length2":32},{"diffs":[[0,"  var b="],[-1,"snake."],[0,"orig_lay"]],"start1":22040,"start2":22040,"length1":22,"length2":16}]],"length":23022,"saved":false}
{"ts":1341117455464,"patch":[[{"diffs":[[0,"();\n"],[-1,"     addKeyListener();\n"],[0,"    "]],"start1":22314,"start2":22314,"length1":31,"length2":8},{"diffs":[[0,"rk_point();\n"],[1,"     addKeyListener();\n"],[0,"    }\n    fu"]],"start1":22354,"start2":22354,"length1":24,"length2":47}]],"length":23022,"saved":false}
{"ts":1341117536837,"patch":[[{"diffs":[[0,"ntLayout();\n"],[1,"     setDimensionsForPlayground();\n"],[0,"     make_in"]],"start1":22306,"start2":22306,"length1":24,"length2":59}]],"length":23057,"saved":false}
{"ts":1341117627060,"patch":[[{"diffs":[[0,"SIZE));\n"],[1,"\n"],[0,"    "],[1,"var snake_playground=createSnakeElement({\n        tagName:'div',\n        className:'snake_playground',\n        id:'snake_playground',\n        style:{\n            height:height,\n            width:width\n                }\n        });//Its the root element for the snake game\n"],[0,"\n    }\n\n"]],"start1":2551,"start2":2551,"length1":20,"length2":293},{"diffs":[[0,"   \n"],[-1,"    var snake_playground=createSnakeElement({\n        tagName:'div',\n        className:'snake_playground',\n        id:'snake_playground',\n        style:{\n            height:height,\n            width:width\n                }\n        });//Its the root element for the snake game\n"],[0,"    "]],"start1":3871,"start2":3871,"length1":284,"length2":8}]],"length":23054,"saved":false}
{"ts":1341117647070,"patch":[[{"diffs":[[0,"IZE));\n\n    "],[-1,"var "],[0,"snake_playgr"]],"start1":2552,"start2":2552,"length1":28,"length2":24}]],"length":23050,"saved":false}
{"contributors":[],"silentsave":false,"ts":1341729000379,"patch":[[{"diffs":[[0,"in()"],[-1,"\n{\n    //\"use strict\";\n    var LEFT_KEY_CODE=37;\n    var UP_KEY_CODE=38;\n    var RIGHT_KEY_CODE=39;\n    var DOWN_KEY_CODE=40;\n    var ESCAPE_KEY_CODE=27;\n    var SPACE_KEY_CODE=32;//TO PAUSE THE GAME\n\n    var NO_OF_INITIAL_BODY_PARTS=20;\n    var POSITIVE_90_ROTATION=\"rotate(90deg)\";\n    var NEGATIVE_90_ROTATION=\"rotate(-90deg)\";\n    var NEGATIVE_180_ROTATION=\"rotate(-180deg)\";\n    var ZERO_ROTATION=\"\";\n    var BODY_PART_SIZE=20;\n    var SPEED=70;\n    var INCREASE_SIZE_BY=4;\n    var GULP_COUNTER_DIV_ID='snake_gulp_counter';\n    var GULP_COUNTER_DIV_CLASS='counter';\n    var LAST_BODY_PART_SELECTOR='#snake span:nth-last-child(1)';\n    var SNAKE_FIGURE='<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"><rect class=\"snake_figure\" id=\"snake_figure\" width=\"'+BODY_PART_SIZE+'\" height=\"'+BODY_PART_SIZE+'\"/></svg>';\n    var SNAKE_BODY_PART_CLASS='snake_body_part';\n    var SNAKE_BODY_PART_ID='snake_body_part';\n    var body=document.body;\n /*    var LIST_OF_ELEMENTS=[\n     'body'   \n    ]//A list of those elements whose style will be saved and restored;We will be modifyin only the internal style.\n */  \n    var snake=window.snake={};//Snake Namespace    \n    var point=snake.point={};//Holds the position of the point.\n    var orig_layout=snake.orig_layout={}//It will hold the original style information for the page\n    var key_queue=snake.key_queue=[];//Holds the keys to be processed\n    var isDestroyed=snake.isDestroyed=false;\n    \n    var window_availWidth=-1,window_availHeight=-1,width=-1,height=-1;\n    \n    function setDimensionsForPlayground(){\n    var screen_height=screen.height;\n    var screen_width=screen.width;\n    var body_height=document.body.clientHeight;\n    var body_width=document.body.clientWidth;\n    var docel_height=document.documentElement.clientHeight;\n    var docel_width=document.documentElement.clientWidth;\n    var maxh=Math.max(body_height,docel_height);\n    var maxw=Math.max(body_width,docel_width);\n    var minh=Math.min(body_height,docel_height);\n    var minw=Math.min(body_width,docel_width);\n    if(maxh>screen_height)\n    window_availHeight=minh;\n    else\n    window_availHeight=maxh;\n    \n    if(maxw>screen_width)\n    window_availWidth=minw;\n    else\n    window_availWidth=maxw;\n    \n    \n    //Adjust the size of snake playground according to the available size of page and integral multiple of the movement made by snake\n    snake.width=Math.floor(window_availWidth-(window_availWidth%BODY_PART_SIZE));\n    snake.height=Math.floor(window_availHeight-(window_availHeight%BODY_PART_SIZE));\n\n    snake_playground=createSnakeElement({\n        tagName:'div',\n        className:'snake_playground',\n        id:'snake_playground',\n        style:{\n            height:height,\n            width:width\n                }\n        });//Its the root element for the snake game\n\n    }\n\n    function getIntegerPartFromString(str)\n    {\n        return parseInt(str,10);\n    }\n    function createSnakeElement(props)\n    {\n        var el=document.createElement(props.tagName);\n        \n        if(props.className)\n        el.setAttribute('class',props.className);\n        \n        if(props.id)\n        el.setAttribute('id',props.id);\n        \n        if(props.innerHTML)\n        el.innerHTML=props.innerHTML;        \n        \n        if(props.style)\n        {\n        if(!(typeof props.style.left == \"undefined\"))\n        el.style.left=props.style.left+\"px\";\n        \n        if(!(typeof props.style.top == \"undefined\"))\n        el.style.top=props.style.top+\"px\";\n        \n        if(!(typeof props.style.height == \"undefined\"))\n        el.style.height=props.style.height+\"px\";\n        \n        if(!(typeof props.style.width == \"undefined\"))\n        el.style.width=props.style.width+\"px\";\n        }\n        el.appendChildWithInformation=appendChildWithInformation;\n                \n        \n        return el;\n    }\n    \n    \n    \n    function appendChildWithInformation(child){\n    var el=createSnakeElement(child);\n    this.appendChild(el);\n    return el;\n    }\n    \n\n    var snake_body=snake_playground.appendChildWithInformation({\n        tagName:'div',\n        className:'snake',\n        id:'snake',\n        style:{\n                height:height,\n                width:width\n              }\n        });\n\n    \n    \n    var gulp_counter_el=snake_playground.appendChildWithInformation({tagName:'div',\n              className:GULP_COUNTER_DIV_CLASS,\n              id:GULP_COUNTER_DIV_ID,\n              innerHTML:'0'\n             });\n             \n    var state_of_game_el=snake_playground.appendChildWithInformation({tagName:'div',\n             className:'snake_state',\n             id:'snake_state',\n             innerHTML:'PAUSED'\n    });\n    \n    //Finally append the snake playground to the body.\n    body.appendChild(snake_playground);\n\n    \n    function restart_game()\n    {\n        kill_game();\n        main(); \n    }\n    \n    function mark_point()\n    {\n         var x=(Math.random())*(getIntegerPartFromString(snake_playground.style.width));\n         var y=(Math.random())*(getIntegerPartFromString(snake_playground.style.height));\n         x=Math.ceil(x);\n         y=Math.ceil(y);\n\n         //Hnandle the case when random no is 1\n         x-=BODY_PART_SIZE;\n         y-=BODY_PART_SIZE;\n         \n         x=x-(x%BODY_PART_SIZE);\n         y=y-(y%BODY_PART_SIZE);\n         point.el=snake_playground.appendChildWithInformation({\n             tagName:'div',\n             className:'snake_point',\n             id:'snake_point',\n             innerHTML:SNAKE_FIGURE,\n             style:{\n                    left:x,\n                    top:y\n                    }\n             });\n         \n         //Store the position of the point in snake namespace for easy accessibilty\n         point.x=x;\n         point.y=y;\n        }\n    \n    function add_to_queue(keyCode)\n    {\n        //FOR NOW ONLY THE LAST ELEMENT of QUEUE IS CONSIDERED\n        if(key_queue.length==1)\n        {\n         key_queue.shift();\n        }\n        \n        key_queue.push(keyCode);\n    }\n    function keypress_listener(e)\n    {\n        if(e.keyCode==LEFT_KEY_CODE ||e.keyCode==DOWN_KEY_CODE ||e.keyCode==UP_KEY_CODE ||e.keyCode==RIGHT_KEY_CODE )\n        {\n         e.preventDefault();\n         e.stopPropagation();\n         if(!isDestroyed)\n          add_to_queue(e.keyCode);\n         else\n         alert('Game has already ended')\n        }\n        else \n        {\n         if(e.keyCode==ESCAPE_KEY_CODE)\n         {\n            if(isDestroyed)\n            return;\n            e.preventDefault();\n            e.stopPropagation();\n            kill_game();\n         }\n         else if(e.keyCode==SPACE_KEY_CODE)\n         {\n             e.preventDefault();\n             e.stopPropagation();              \n              if(snake.paused===true)\n              resume();\n              else\n              pause();\n              \n              snake.paused=toggle(snake.paused);\n         }"],[1," {\n    \"use strict\";\n    var LEFT_KEY_CODE = 37,\n        UP_KEY_CODE = 38,\n        RIGHT_KEY_CODE = 39,\n        DOWN_KEY_CODE = 40,\n        ESCAPE_KEY_CODE = 27,\n        SPACE_KEY_CODE = 32,//TO PAUSE THE GAME\n        R_KEY_CODE = 82,//Restart\n        NO_OF_INITIAL_BODY_PARTS = 3,\n        POSITIVE_90_ROTATION = \"rotate(90deg)\",\n        NEGATIVE_90_ROTATION = \"rotate(-90deg)\",\n        NEGATIVE_180_ROTATION = \"rotate(-180deg)\",\n        ZERO_ROTATION = \"\",\n        BODY_PART_SIZE = 20,\n        SPEED = 60,\n        INCREASE_SIZE_BY = 1,\n        GULP_COUNTER_DIV_ID = 'snake_gulp_counter',\n        GULP_COUNTER_DIV_CLASS = 'snake_gulp_counter',\n        LAST_BODY_PART_SELECTOR = '#snake span:nth-last-child(1)',\n        SNAKE_FIGURE = '<svg xmlns = \"http://www.w3.org/2000/svg\" version=\"1.1\"><rect class=\"snake_figure\" id=\"snake_figure\" width=\"' + BODY_PART_SIZE + '\" height=\"' + BODY_PART_SIZE + '\"/></svg>',\n        PLAYGROUND_CLASS = 'snake_playground',\n        PLAYGROUND_ID = 'snake_playground',\n        SNAKE_BODY_CLASS = 'snake',\n        SNAKE_BODY_ID = 'snake',\n        SNAKE_BODY_PART_CLASS = 'snake_body_part',\n        SNAKE_BODY_PART_ID = 'snake_body_part',\n        GAME_STATE_CLASS = 'snake_state',\n        GAME_STATE_ID = 'snake_state',\n        GAME_STATE_HTML = '<b>PAUSED</b>',\n        CRASH_OPTIONS_CLASS = 'crash_options',\n        CRASH_OPTIONS_ID = 'crash_options',\n        CRASH_OPTIONS_HTML = \"Press <b><i>'r'</i></b> to Restart or <b><i>'Esc'</i></b> to Exit\",\n        IFRAME_ID = \"snake_iframe\",\n        STATES = {\n            RUNNING: 0, \n            PAUSED: 1,\n            ENDED: 2, //Game has ended .But things are still there.\n            INITIALISING: 3,\n            DESTROYED: 4 //Games has ended and complete playground has been destroyed\n            },\n        body = document.body,\n        snake = window.snake = {},//Snake Namespace\n        point = snake.point = {},//Holds the position of the point.\n        orig_layout = snake.orig_layout = {},//It will hold the original style information for the page\n        key_queue = snake.key_queue = [],//Holds the keys to be processed\n        window_availWidth = -1,\n        window_availHeight = -1,\n        width = -1,\n        height = -1,\n        snake_playground = {},\n        snake_body = {},\n        state_of_game_el = {},\n        gulp_counter_el = {},\n        startover_max_counter = 0,\n        crash_options;\n    function getIntPartFromStr(str) {\n        return parseInt(str, 10);\n    }\n    function isDestroyed() {\n        if (snake.state === STATES.DESTROYED) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function isEnded() {\n        if (snake.state === STATES.ENDED) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function copy_style(el, save_obj) {\n        var style = el.style,\n            obj_style = {},\n            i;\n        if (!save_obj.style) {\n            obj_style = save_obj.style = {};\n        } else {\n            obj_style = save_obj.style;\n        }\n        for (i in style) { //TODO:Need to be more specific cause style can have methods too.This is a very genric approach,can cause problem in future\n            obj_style[i] = style[i];"],[0,"\n   "]],"start1":12,"start2":12,"length1":6899,"length2":3234},{"diffs":[[0,";\n        }\n"],[-1,"        \n"],[0,"    }\n    fu"]],"start1":3241,"start2":3241,"length1":33,"length2":24},{"diffs":[[0,"    "],[-1,"if(typeof boolvar !='boolean')\n     {\n         throw new Error('boolvar is not a bool');\n     }\n     if(boolvar===true)\n     boolvar=false;\n     else\n     boolvar=true;\n     return boolvar;\n    }\n    \n    function kill_game() \n    {\n        stop();\n        try\n        {\n         if(snake_playground)\n         {\n          body.removeChild(snake_playground);\n         }\n        }\n        catch(e)\n        {\n          console.log('Exception:',\"Caller is =\"+kill_game.caller,\"ParentNode=\"+snake_playground.parentNode,\"Node=\"+snake_playground);\n        }\n        RestoreLayout();\n    }\n    \n    function check_for_overlap(el)\n    {\n      //TODO:copy childnodes to an array cause domenodes processing is costly\n      var last=body.querySelector(LAST_BODY_PART_SELECTOR);\n      var last_style=last.style;\n      var last_style_top=last_style.top;\n      var last_style_left=last_style.left;\n      var len=el.childNodes.length;\n      for(var i=0;i<len-1;i++)\n      {\n       var child=el.childNodes[i];\n       var child_style=child.style;\n       var top=child_style.top;\n       var left=child_style.left;\n       if((top==last_style_top) && (left==last_style_left))\n       snake_crashed_into_wall();\n      }        \n    }\n    \n    function check_for_up_crash(last_style)\n    {\n        if((getIntegerPartFromString(last_style.top))<0)\n        snake_crashed_into_wall();\n    }\n    function check_for_left_crash(last_style)\n    {\n        if((getIntegerPartFromString(last_style.left))<0)\n        snake_crashed_into_wall();\n    }\n    function check_for_right_crash(last_style,offset)\n    {\n       if((getIntegerPartFromString(last_style.left)+offset)>window_availWidth)\n                snake_crashed_into_wall();            \n    }\n   function check_for_down_crash(last_style,offset)\n   {\n          if((getIntegerPartFromString(last_style.top)+offset)>window_availHeight)\n            snake_crashed_into_wall();    \n   }\n\n    function process_keypress(el,keyCode)\n    {\n        var no_of_child_nodes=el.childNodes.length;\n        var rotation={};\n        rotation.value=el.childNodes[(no_of_child_nodes-1)].rotation;\n        el.childNodes[no_of_child_nodes-1].rotation=rotation.value=(typeof rotation.value==\"undefined\")?ZERO_ROTATION:rotation.value;\n        rotation.isNeg90=(rotation.value==NEGATIVE_90_ROTATION );\n        rotation.isPos90=(rotation.value==POSITIVE_90_ROTATION );\n        rotation.isNeg180=(rotation.value==NEGATIVE_180_ROTATION );\n        rotation.isZero=(rotation.value==ZERO_ROTATION );\n        \n        var move_distance=BODY_PART_SIZE;\n        var last=document.body.querySelector(LAST_BODY_PART_SELECTOR);\n        var last_style=last.style;\n        var offset=BODY_PART_SIZE;        \n        var isItTheExpectedKey=true;\n        switch(keyCode)\n        {\n            case LEFT_KEY_CODE:\n            if(rotation.isNeg90 || rotation.isPos90 || rotation.isNeg180)\n            {\n                process_left_key(el,move_distance);\n                check_for_left_crash(last_style);\n            }\n            break;\n            \n            case UP_KEY_CODE:\n            if(rotation.isNeg90 ||rotation.isZero || rotation.isNeg180)\n            {\n                process_up_key(el,move_distance);\n                check_for_up_crash(last_style);            \n            }\n            break;\n            \n            case RIGHT_KEY_CODE:\n            if(rotation.isPos90 || rotation.isZero || rotation.isNeg90)\n            {\n                process_right_key(el,move_distance);\n                check_for_right_crash(last_style,offset);      \n            }\n            break;\n\n            case DOWN_KEY_CODE:\n            if(rotation.isPos90 || rotation.isZero || rotation.isNeg180)\n            {\n                process_down_key(el,move_distance)\n                check_for_down_crash(last_style,offset);\n            }\n            break;\n            \n            default:\n            isItTheExpectedKey=false;\n            alert('Unexpected key');\n       }\n       if(isItTheExpectedKey)\n       {\n           try_to_gulp(el);\n       }\n   }\n   \n    function try_to_gulp(el)\n    {\n      var last=body.querySelector(LAST_BODY_PART_SELECTOR);\n      var last_style=last.style;\n      var last_style_top=last_style.top;\n      var last_style_left=last_style.left;\n      if(((snake.point.x+\"px\")==last_style_left) && ((snake.point.y+\"px\")==last_style_top))\n      {\n          snake_playground.removeChild(point.el);\n          gulp(el,true);\n          mark_point();\n      }      \n    }\n    function gulp(el,consume)\n    {\n        if((typeof gulp.id) == \"undefined\")\n        gulp.id=0;\n        if((typeof gulp.count) == \"undefined\")\n        gulp.count=0;\n        if(consume===true)\n        {\n         for(var i=0;i<INCREASE_SIZE_BY;i++)\n         {         \n          gulp.id+=1;\n          \n          var offsetx=0;\n          var offsety=0;\n          var firstChild=el.childNodes[0];\n          var firstChild_style=firstChild.style;\n          var left=getIntegerPartFromString(firstChild_style.left);\n          var top=getIntegerPartFromString(firstChild_style.top);\n          var rotation=firstChild.rotation;\n          \n          \n          //The insertion philosophy is opposite to usual\n          if(rotation==NEGATIVE_180_ROTATION)\n          offsetx=BODY_PART_SIZE;\n          else if(rotation==ZERO_ROTATION)\n          offsetx=-BODY_PART_SIZE;\n          else if(rotation==POSITIVE_90_ROTATION)\n          offsety=-BODY_PART_SIZE;\n          else if(rotation==NEGATIVE_90_ROTATION)\n          offsety=BODY_PART_SIZE;\n         \n          if((offsetx===0) && (offsety===0))\n          console.log(\"RAISE EXCEPTION HERE\");\n         \n          var span=createSnakeElement({\n                tagName:'span',\n                className:SNAKE_BODY_PART_CLASS,\n                id:SNAKE_BODY_PART_ID+gulp.id,\n                innerHTML:SNAKE_FIGURE,\n                style:{\n                       left:left+offsetx,\n                       top:top+offsety\n                      }\n                });\n          span.rotation=rotation;\n\n          el.insertBefore(span,el.childNodes[0]);\n         }\n         gulp.count+=1;\n         gulp_counter_el.innerHTML=gulp.count;\n        }\n        else\n        {\n            gulp.id+=1;\n            el.appendChildWithInformation({\n                tagName:'span',\n                className:SNAKE_BODY_PART_CLASS,\n                id:SNAKE_BODY_PART_ID+gulp.id,\n                innerHTML:SNAKE_FIGURE,\n                style:{\n                       left:0,\n                       top:0\n                      }\n                });\n        }\n        \n    }\n    \n    function snake_crashed_into_wall()\n    {\n          if(isDestroyed)\n          {\n           alert('Already destroyed-snake_crashed_into_wall.Caller is'+snake_crashed_into_wall.caller);\n           return;\n          }\n          isDestroyed=true;\n          //kill_game();\n          var response=confirm(\"Game Over.\\nRestart the Game ?\");          \n          if(response)\n          restart_game();\n          else\n          kill_game();\n    }\n    \n    function process_general(element,distance,leave_last)\n    {    \n        //TODO: make a copy of node list as traversing it is costly.\n        var len=element.childNodes.length;\n        var up_to=len;\n    \n        if(leave_last)\n        up_to=len-1;\n        \n        for(var i=0;i<up_to;i++)\n        {\n         var child=element.childNodes[i];\n         var child_style=child.style;\n         \n         child.rotation=((typeof child.rotation)==\"undefined\")?ZERO_ROTATION:child.rotation;\n         var rotation=child.rotation;\n         \n         var rotation_flag=false;\n         if(child.rotation==POSITIVE_90_ROTATION || child.rotation==NEGATIVE_90_ROTATION)\n         rotation_flag=true;\n         var lookahead_rotation_flag=-1;\n         var left_coordinate=getIntegerPartFromString(child_style.left);\n         var top_coordinate=getIntegerPartFromString(child_style.top);\n\n         if(i+1<len)\n         {\n              if(element.childNodes[i+1].rotation==POSITIVE_90_ROTATION || element.childNodes[i+1].rotation==NEGATIVE_90_ROTATION)\n              lookahead_rotation_flag=true;\n              if(element.childNodes[i+1].rotation==ZERO_ROTATION || element.childNodes[i+1].rotation==NEGATIVE_180_ROTATION)\n              lookahead_rotation_flag=false;\n         }\n         \n         \n         if(((typeof rotation_flag)===\"undefined\") ||  (rotation_flag===false))\n         {\n             child.isRotated=false;\n          \n            if(((typeof lookahead_rotation_flag)!==\"undefined\") && (lookahead_rotation_flag===true))\n            {\n             child.isRotated=true; \n             child.rotation=element.childNodes[i+1].rotation;\n             //Simulate rotation\n             if(child.rotation == NEGATIVE_90_ROTATION)\n             child_style.top=(top_coordinate-(distance))+\"px\";\n             if(child.rotation == POSITIVE_90_ROTATION)\n             child_style.top=(top_coordinate+(distance))+\"px\";\n            }\n            else\n            {\n                   if(rotation==ZERO_ROTATION)\n                child_style.left=(left_coordinate+(distance))+\"px\";\n             else if(rotation==NEGATIVE_180_ROTATION)\n                child_style.left=(left_coordinate-(distance))+\"px\";\n            }\n            \n         }\n         else //rotation flag is true\n         {\n            if(((typeof lookahead_rotation_flag)===\"undefined\") || (lookahead_rotation_flag===false))\n            {\n             child.isRotated=false; \n             child.rotation=element.childNodes[i+1].rotation;\n              //Simulate rotation\n              if(child.rotation == ZERO_ROTATION)\n             child_style.left=(left_coordinate+(distance))+\"px\";\n             if(child.rotation == NEGATIVE_180_ROTATION)\n             child_style.left=(left_coordinate-(distance))+\"px\";\n             \n            }\n            else\n            {\n                 if(rotation==NEGATIVE_90_ROTATION)\n                child_style.top=(top_coordinate-(distance))+'px';\n                else if(rotation==POSITIVE_90_ROTATION)\n                child_style.top=(top_coordinate+(distance))+'px';\n                \n            }\n         }\n         \n        }\n    }\n\n    function process_down_key(element,distance)\n    {\n         var children=element.childNodes;\n         var key=children.length-1;\n         var rotation=children[key].rotation;\n         var child_style=children[key].style;\n         var top_coordinate=getIntegerPartFromString(child_style.top);\n         var leave_last=false;\n         if((rotation==ZERO_ROTATION) || (rotation==NEGATIVE_180_ROTATION))\n         {\n            leave_last=true;\n            process_general(element,distance,leave_last);\n            child_style.top=(top_coordinate+(distance))+\"px\";\n            element.childNodes[key].rotation=POSITIVE_90_ROTATION;\n         }       \n    }\n    \n    function process_up_key(element,distance){\n         \n         var children=element.childNodes;\n         var key=children.length-1;\n         var rotation=children[key].rotation;\n         var child_style=children[key].style;\n         var top_coordinate=getIntegerPartFromString(child_style.top);\n         var leave_last=false;\n         \n         if((rotation==ZERO_ROTATION) || (rotation==NEGATIVE_180_ROTATION))\n         {\n          leave_last=true;\n          process_general(element,distance,leave_last);\n          child_style.top=(top_coordinate-(distance))+\"px\";\n          element.childNodes[key].rotation=NEGATIVE_90_ROTATION;\n         }\n    }\n    \n        \n        function process_right_key(element,distance){\n         var children=element.childNodes;\n         var key=children.length-1;\n         var rotation=children[key].rotation;\n         var child_style=children[key].style;\n         var left_coordinate=getIntegerPartFromString(child_style.left);\n         var leave_last=false;\n         \n         if((rotation==POSITIVE_90_ROTATION) || (rotation==NEGATIVE_90_ROTATION))\n         {\n          leave_last=true;\n          process_general(element,distance,leave_last);\n          child_style.left=(left_coordinate+(distance))+\"px\";\n          element.childNodes[key].rotation=ZERO_ROTATION;\n         }\n      \n    }\n        function process_left_key(element,distance){\n        var children=element.childNodes;\n        var key=children.length-1;\n        var rotation=children[key].rotation;\n        var child_style=children[key].style;\n        var left_coordinate=getIntegerPartFromString(child_style.left);\n        var leave_last=false;\n         \n        if((rotation==POSITIVE_90_ROTATION) || (rotation==NEGATIVE_90_ROTATION))\n        {\n          leave_last=true;\n          process_general(element,distance,leave_last);\n          child_style.left=(left_coordinate-(distance))+\"px\";\n          element.childNodes[key].rotation=NEGATIVE_180_ROTATION;\n         }\n      \n    }\n    function simulate_snake(el)\n    {\n      var queue=key_queue;\n      var len=queue.length;\n      \n      if(len===0)\n      {\n        process_general(el,BODY_PART_SIZE);\n        \n        //Not pressing any key means snake is moving in direction of last body_part\n        var last=body.querySelector(LAST_BODY_PART_SELECTOR);\n        var rotation=last.rotation;\n        var last_style=last.style;\n       // console.log(\"STYLE\",last_style)\n        var offset=BODY_PART_SIZE;//Need to adjust it\n        if(rotation==NEGATIVE_180_ROTATION)\n         {\n             check_for_left_crash(last_style);\n         }\n         else if(rotation==ZERO_ROTATION)\n         {\n          check_for_right_crash(last_style,offset);\n         }\n         else if(rotation==POSITIVE_90_ROTATION)\n         {\n             check_for_down_crash(last_style,offset);\n         }\n         else if(rotation==NEGATIVE_90_ROTATION)\n         {\n             check_for_up_crash(last_style);\n         }\n         if(isDestroyed)\n         return;\n         check_for_overlap(el);\n         try_to_gulp(el);\n      }\n      else\n      {\n       process_keypress(el,queue.pop());\n      }\n    }\n    \n    function make_initial_snake(el)\n    {\n     for(var i=0;i<NO_OF_INITIAL_BODY_PARTS;i++)\n     {\n        gulp(el);\n        if(i>=1 && (i< NO_OF_INITIAL_BODY_PARTS))\n        {\n         el.childNodes[i].style.left=(getIntegerPartFromString(el.childNodes[i].style.left)+(i*BODY_PART_SIZE))+\"px\";\n        }\n     }\n     snake.paused=true;\n    }\n    function copy_style(el,save_obj)\n    {\n        var style=el.style;\n        var obj_style={};\n        \n        if(!save_obj.style)\n        obj_style=save_obj.style={};\n        else\n        obj_style=save_obj.style;\n        \n        for(var i in style)\n        {\n            obj_style[i]=style[i];\n        }\n    }\n    //Save the current style info in case something wrong happens or fore restoration\n    function SaveCurrentLayoutInfo()\n    {\n      var b=orig_layout.body={};\n      b.style={};\n      b.style.overflow=body.style.overflow;\n      b.style.margin=body.style.margin;\n      //copy_style(body,snake.orig_layout.body);\n    }\n    \n    function ModifyCurrentLayout()\n    {\n        body.style.overflow=\"hidden\";\n        body.style.margin=\"0\";\n    }\n    \n    function RestoreLayout()\n    {\n      var b=orig_layout.body;\n      body.style.overflow=b.style.overflow;\n      body.style.margin=b.style.margin;\n        //copy_style(snake.orig_layout.body,body.style);\n        \n    }\n    \n    function start(el)\n    {\n     SaveCurrentLayoutInfo();    \n     ModifyCurrentLayout();\n     setDimensionsForPlayground();\n     make_initial_snake(el);\n     mark_point();\n     addKeyListener();\n    }\n    function stop()\n    {\n     clearInterval(snake.interval);    \n     removeKeyListener();\n    }\n    function pause()\n    {\n     state_of_game_el.innerHTML=\"PAUSED\";    \n     clearInterval(snake.interval);   \n    }\n    function resume()\n    {\n        state_of_game_el.innerHTML=\"\";\n        snake.interval=setInterval(function(){simulate_snake(snake_body);},SPEED);\n    }\n    function addKeyListener()\n    {\n     document.addEventListener(\"keydown\",keypress_listener,true);\n    }\n    function removeKeyListener()\n    {\n     document.removeEventListener(\"keydown\",keypress_listener,true);\n    }\n    start(snake_body);    \n})();\n"],[1,"   if (typeof boolvar !== 'boolean') {\n            throw new Error('boolvar is not a bool');\n        }\n        if (boolvar === true)\n        {\n            boolvar = false;\n        } else {\n            boolvar = true;\n        }\n        return boolvar;\n    }\n    //Save the current style info in case something wrong happens or fore restoration\n    function saveCurrentLayout() {\n        var b = orig_layout.body = {};\n        b.style = {};\n        b.style.overflow = body.style.overflow;\n        b.style.margin = body.style.margin;\n        //copy_style(body, snake.orig_layout.body);\n    }\n    function modifyLayout() {\n        body.style.overflow = \"hidden\";\n        body.style.margin = \"0\";\n    }    \n    function moveStateTo(state) {\n        if (state === STATES.PAUSED) {\n            snake.state = state;\n            state_of_game_el.innerHTML = \"PAUSED\";\n            clearInterval(snake.interval);\n        } else if (state === STATES.ENDED) {\n            snake.state = state;\n            state_of_game_el.innerHTML = \"ENDED\";\n            clearInterval(snake.interval);\n        } else if (state == STATES.RUNNING) {\n            state_of_game_el.innerHTML = \"\";\n            snake.interval = setInterval(function() {simulateSnake(snake_body);}, SPEED);\n        }\n    }\n    function getDimensions() {\n        window_availWidth = snake_playground.offsetWidth;\n        window_availHeight = snake_playground.offsetHeight;\n        width = snake.width = Math.floor(window_availWidth-(window_availWidth%BODY_PART_SIZE));\n        height = snake.height = Math.floor(window_availHeight-(window_availHeight%BODY_PART_SIZE));\n    }\n    function appendChildWithInformation(child) {\n        var el = createSnakeElement(child);\n        this.appendChild(el);\n        return el;\n    }\n    function createSnakeElement(props) {\n        var el = document.createElement(props.tagName),\n            props_style=props.style;\n        if (props.className) {\n            el.setAttribute('class', props.className);\n        }\n        if (props.id) {\n            el.setAttribute('id', props.id);\n        }\n        if (props.innerHTML) {\n            el.innerHTML = props.innerHTML;\n        }\n        if ((typeof props_style) !== \"undefined\") {\n            if ((typeof props_style.left) !== \"undefined\") {\n                el.style.left = props.style.left;\n            }\n            if ((typeof props_style.top) !== \"undefined\") {\n                el.style.top = props.style.top;\n            }\n            if ((typeof props_style.height) !== \"undefined\") {\n                el.style.height = props.style.height;\n            }\n            if ((typeof props_style.width) !== \"undefined\") {\n                el.style.width = props.style.width;\n            }\n        }\n        el.appendChildWithInformation = appendChildWithInformation;\n        return el;\n    }\n    function insertFrame() {\n        var iframe = document.createElement('iframe');\n        iframe.setAttribute('id',IFRAME_ID);\n    }\n    function setupPlayground() {\n        snake_playground = createSnakeElement({\n            tagName: 'div',\n            className: PLAYGROUND_CLASS,\n            id: PLAYGROUND_ID,\n            style: {\n            height: \"100%\",\n            width: \"100%\"\n        }\n    });//Its the root element for the snake game\n        snake_body = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: SNAKE_BODY_CLASS,\n            id: SNAKE_BODY_ID,\n            style: {\n            }\n        });\n        gulp_counter_el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: GULP_COUNTER_DIV_CLASS,\n            id: GULP_COUNTER_DIV_ID,\n            innerHTML: '0'\n        });\n        state_of_game_el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: GAME_STATE_CLASS,\n            id: GAME_STATE_ID,\n            innerHTML: GAME_STATE_HTML\n        });\n        crash_options = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: CRASH_OPTIONS_CLASS,\n            id: CRASH_OPTIONS_ID,\n            innerHTML: CRASH_OPTIONS_HTML\n        });\n        //Finally append the snake playground to the body.\n        body.appendChild(snake_playground);\n        insertFrame();\n    }\n    function gulp(el, consume) {\n        var i;\n        if((typeof gulp.id) === \"undefined\") {\n            gulp.id=0;\n        }\n        if((typeof gulp.count) === \"undefined\") {\n            gulp.count=0;\n        }\n        if(consume === true) {\n            for (i = 0; i < INCREASE_SIZE_BY; i++) {\n                gulp.id+=1;\n                var offsetx=0;\n                var offsety=0;\n                var firstChild = el.childNodes[0];\n                var firstChild_style = firstChild.style;\n                var left = getIntPartFromStr(firstChild_style.left);\n                var top = getIntPartFromStr(firstChild_style.top);\n                var rotation = firstChild.rotation;\n                //The insertion philosophy is opposite to usual\n                if(rotation === NEGATIVE_180_ROTATION) {\n                    offsetx = BODY_PART_SIZE;\n                } else if(rotation === ZERO_ROTATION) {\n                    offsetx=-BODY_PART_SIZE;\n                } else if(rotation === POSITIVE_90_ROTATION) {\n                    offsety=-BODY_PART_SIZE;\n                } else if(rotation === NEGATIVE_90_ROTATION) {\n                    offsety = BODY_PART_SIZE;\n                }\n                if((offsetx === 0) && (offsety === 0)) {\n                    console.log(\"RAISE EXCEPTION HERE\");\n                }\n                var span = createSnakeElement({\n                    tagName: 'span',\n                    className: SNAKE_BODY_PART_CLASS,\n                    id: SNAKE_BODY_PART_ID+gulp.id,\n                    innerHTML: SNAKE_FIGURE,\n                    style: {\n                        left:left+offsetx+\"px\",\n                        top:top+offsety+\"px\"\n                    }\n                });\n                span.rotation = rotation;\n                el.insertBefore(span, el.childNodes[0]);\n            }\n            gulp.count+=1;\n            gulp_counter_el.innerHTML = gulp.count;\n        } else {\n            gulp.id+=1;\n            el.appendChildWithInformation.call(el, {\n                tagName:'span',\n                className:SNAKE_BODY_PART_CLASS,\n                id:SNAKE_BODY_PART_ID+gulp.id,\n                innerHTML:SNAKE_FIGURE,\n                style:{\n                    left:0,\n                    top:0\n                }\n            });\n        }\n    }\n    function makeInitialSnake(el) {\n        var i;\n        for (i = 0; i < NO_OF_INITIAL_BODY_PARTS; i++) {\n            gulp(el);\n            if(i >= 1 && (i <  NO_OF_INITIAL_BODY_PARTS)) {\n                el.childNodes[i].style.left=(getIntPartFromStr(el.childNodes[i].style.left)+(i*BODY_PART_SIZE))+\"px\";\n            }\n        }\n        snake.paused = true;\n    }\n    function restoreLayout() {\n        var b = orig_layout.body;\n        body.style.overflow = b.style.overflow;\n        body.style.margin = b.style.margin;\n    }\n    function markPoint(el) {\n        var x = -1,\n            y = -1,\n            count = 0,\n            len = el.childNodes.length;\n        while(true) {\n            var startover = false,\n                randx = Math.random(),\n                randy = Math.random(),\n                i;\n            x = (randx)*(getIntPartFromStr(width)-BODY_PART_SIZE);\n            y = (randy)*(getIntPartFromStr(height)-BODY_PART_SIZE);\n            x = x-(x%BODY_PART_SIZE);\n            y = y-(y%BODY_PART_SIZE);\n            for(i = 0; i < len-1; i++) {\n                var child = el.childNodes[i],\n                    child_style = child.style,\n                    top = child_style.top,\n                    left = child_style.left;\n                if((top === (y + \"px\")) && (left === (x + \"px\"))) {\n                    startover = true;\n                    if(startover_max_counter < count) {\n                        startover_max_counter = count;\n                        console.log(\"Startovercount highest value=\", startover_max_counter);\n                    }\n                    break;\n                }\n            }\n            if(!startover) {\n                break;\n            } else {\n                count++;\n            }\n        }\n        point.el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName:'div',\n            className:'snake_point',\n            id:'snake_point',\n            innerHTML:SNAKE_FIGURE,\n            style:{\n                left:x+\"px\",\n                top:y+\"px\"\n            }\n        });\n        //Store the position of the point in snake namespace for easy accessibilty\n        point.x = x;\n        point.y = y;\n    }\n    function append(keyCode) {\n        //FOR NOW ONLY THE LAST ELEMENT of QUEUE IS CONSIDERED\n        if(key_queue.length === 1) {\n            key_queue.shift();\n        }\n        key_queue.push(keyCode);\n    }\n    function addKeyListener() {\n        document.addEventListener(\"keydown\", keyEventListener, true);\n    }\n    function removeKeyListener() {\n        document.removeEventListener(\"keydown\", keyEventListener, true);\n    }\n    function freeze() {\n        clearInterval(snake.interval);\n        removeKeyListener();\n    }\n    function killGame() {\n        var script = document.getElementById('snake_script');\n        freeze();\n        try {\n            if(snake_playground) {\n                body.removeChild(snake_playground);\n            }\n        }\n        catch(e) {\n            console.log('Exception:', \"Caller is =\"+killGame.caller, \"ParentNode=\"+snake_playground.parentNode, \"Node=\"+snake_playground);\n        }\n        restoreLayout();\n        if(script)\n        document.getElementsByTagName('head')[0].removeChild(script);\n    }\n    function restartGame() {\n        killGame();\n        main();\n    }\n    function crashSnake() {\n        if(isDestroyed() || (snake.state === STATES.ENDED)) {\n            console.log('Crash Snake-STATE:',snake.state);\n            return;\n        }\n        crash_options.style.display = \"block\";\n        moveStateTo(STATES.ENDED)\n    }\n    function checkUpCrash(last_style) {\n        if((getIntPartFromStr(last_style.top)) < 0) {\n            crashSnake();\n        }\n    }\n    function checkLeftCrash(last_style) {\n        if((getIntPartFromStr(last_style.left)) < 0) {\n            crashSnake();\n        }\n    }\n    function checkRightCrash(last_style, offset) {\n        if((getIntPartFromStr(last_style.left)+offset) > width) {\n            crashSnake();\n        }\n    }\n    function checkDownCrash(last_style, offset) {\n        if((getIntPartFromStr(last_style.top)+offset) > height) {\n            crashSnake();\n        }\n    }\n    function processGeneral(element, distance, leave_last) {\n        //TODO: make a copy of node list as traversing it is costly.\n        var len = element.childNodes.length,\n            up_to = len,\n            i;\n        if(leave_last) {\n            up_to = len-1;\n        }\n        for(i = 0; i < up_to; i++) {\n            var child = element.childNodes[i],\n                child_style = child.style,\n                rotation,\n                rotation_flag = false,\n                lookahead_rotation_flag,\n                left_coordinate,\n                top_coordinate;\n            child.rotation=((typeof child.rotation) === \"undefined\")?ZERO_ROTATION:child.rotation;\n            rotation = child.rotation;            \n            if(child.rotation === POSITIVE_90_ROTATION || child.rotation === NEGATIVE_90_ROTATION) {\n                rotation_flag = true;\n            }\n            lookahead_rotation_flag=-1;\n            left_coordinate = getIntPartFromStr(child_style.left);\n            top_coordinate = getIntPartFromStr(child_style.top);\n            if(i+1 < len) {\n                if(element.childNodes[i+1].rotation === POSITIVE_90_ROTATION || element.childNodes[i+1].rotation === NEGATIVE_90_ROTATION) {\n                    lookahead_rotation_flag = true;\n                }\n                if(element.childNodes[i+1].rotation === ZERO_ROTATION || element.childNodes[i+1].rotation === NEGATIVE_180_ROTATION) {\n                    lookahead_rotation_flag = false;\n                }\n            }\n            if(((typeof rotation_flag) === \"undefined\") || (rotation_flag === false)) {\n                child.isRotated = false;\n                if(((typeof lookahead_rotation_flag) !== \"undefined\") && (lookahead_rotation_flag === true)) {\n                    child.isRotated = true;\n                    child.rotation = element.childNodes[i+1].rotation;\n                    //Simulate rotation\n                    if(child.rotation === NEGATIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate-(distance)) + \"px\";\n                    }\n                    if(child.rotation === POSITIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate+(distance)) + \"px\";\n                    }\n                } else {\n                    if(rotation === ZERO_ROTATION) {\n                        child_style.left = (left_coordinate+(distance)) + \"px\";\n                    } else if(rotation === NEGATIVE_180_ROTATION) {\n                        child_style.left = (left_coordinate-(distance)) + \"px\";\n                    }\n                }\n            }\n            else {//rotation flag is true\n                if(((typeof lookahead_rotation_flag) === \"undefined\") || (lookahead_rotation_flag === false)) {\n                    child.isRotated = false;\n                    child.rotation = element.childNodes[i+1].rotation;\n                    //Simulate rotation\n                    if(child.rotation === ZERO_ROTATION) {\n                        child_style.left = (left_coordinate + (distance)) + \"px\";\n                    }\n                    if(child.rotation === NEGATIVE_180_ROTATION) {\n                        child_style.left = (left_coordinate-(distance))+\"px\";\n                    }\n                }\n                else\n                {\n                    if(rotation === NEGATIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate-(distance))+'px';\n                    }\n                    else if(rotation === POSITIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate+(distance))+'px';\n                    }\n                }\n            }\n        }\n    }\n    function checkOverlap(el) {\n        //TODO:copy childnodes to an array cause domenodes processing is costly\n        var last = body.querySelector(LAST_BODY_PART_SELECTOR),\n            last_style = last.style,\n            last_style_top = last_style.top,\n            last_style_left = last_style.left,\n            len = el.childNodes.length,\n            i;\n        for(i = 0; i < len-1; i++) {\n            var child = el.childNodes[i],\n                child_style = child.style,\n                top = child_style.top,\n                left = child_style.left;\n            if((top === last_style_top) && (left === last_style_left)) {\n                crashSnake();\n            }\n        }\n    }\n    function tryGulp(el) {\n        var last = body.querySelector(LAST_BODY_PART_SELECTOR);\n        var last_style = last.style;\n        var last_style_top = last_style.top;\n        var last_style_left = last_style.left;\n        if(((snake.point.x+\"px\") === last_style_left) && ((snake.point.y+\"px\") === last_style_top)) {\n            snake_playground.removeChild(point.el);\n            gulp(el, true);\n            markPoint(el);\n        }\n    }\n    function processDownKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var top_coordinate = getIntPartFromStr(child_style.top);\n        var leave_last = false;\n        if((rotation === ZERO_ROTATION) || (rotation === NEGATIVE_180_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.top = (top_coordinate + (distance)) + \"px\";\n            element.childNodes[key].rotation = POSITIVE_90_ROTATION;\n        }\n    }\n    function processUpKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var top_coordinate = getIntPartFromStr(child_style.top);\n        var leave_last = false;\n        if((rotation === ZERO_ROTATION) || (rotation === NEGATIVE_180_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.top = (top_coordinate - (distance)) + \"px\";\n            element.childNodes[key].rotation = NEGATIVE_90_ROTATION;\n        }\n    }\n    function processRightKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var left_coordinate = getIntPartFromStr(child_style.left);\n        var leave_last = false;\n        if((rotation === POSITIVE_90_ROTATION) || (rotation === NEGATIVE_90_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.left = (left_coordinate + (distance)) + \"px\";\n            element.childNodes[key].rotation = ZERO_ROTATION;\n        }\n    }\n    function processLeftKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var left_coordinate = getIntPartFromStr(child_style.left);\n        var leave_last = false;\n        if((rotation === POSITIVE_90_ROTATION) || (rotation === NEGATIVE_90_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.left = (left_coordinate-(distance))+\"px\";\n            element.childNodes[key].rotation = NEGATIVE_180_ROTATION;\n        }\n    }\n    function processKeyEvent(el, keyCode) {\n        var no_of_child_nodes = el.childNodes.length;\n        var rotation = {};\n        rotation.value = el.childNodes[(no_of_child_nodes-1)].rotation;\n        el.childNodes[no_of_child_nodes-1].rotation = rotation.value = (typeof rotation.value === \"undefined\")?ZERO_ROTATION: rotation.value;\n        rotation.isNeg90 = (rotation.value === NEGATIVE_90_ROTATION );\n        rotation.isPos90 = (rotation.value === POSITIVE_90_ROTATION );\n        rotation.isNeg180=(rotation.value === NEGATIVE_180_ROTATION );\n        rotation.isZero = (rotation.value === ZERO_ROTATION );\n        var move_distance = BODY_PART_SIZE;\n        var last = document.body.querySelector(LAST_BODY_PART_SELECTOR);\n        var last_style = last.style;\n        var offset = BODY_PART_SIZE;\n        var isItTheExpectedKey = true;\n        switch(keyCode) {\n            case LEFT_KEY_CODE:\n                if(rotation.isNeg90 || rotation.isPos90 || rotation.isNeg180) {\n                    processLeftKey(el, move_distance);\n                    checkLeftCrash(last_style);\n                }\n                break;\n            case UP_KEY_CODE:\n                if(rotation.isNeg90 ||rotation.isZero || rotation.isNeg180) {\n                    processUpKey(el, move_distance);\n                    checkUpCrash(last_style);\n                }\n                break;\n            case RIGHT_KEY_CODE:\n                if(rotation.isPos90 || rotation.isZero || rotation.isNeg90) {\n                    processRightKey(el, move_distance);\n                    checkRightCrash(last_style, offset);\n                }\n                break;\n            case DOWN_KEY_CODE:\n                if(rotation.isPos90 || rotation.isZero || rotation.isNeg180) {\n                    processDownKey(el, move_distance);\n                    checkDownCrash(last_style, offset);\n                }\n                break;\n            default:\n                isItTheExpectedKey = false;\n                alert('Unexpected key');\n        }\n        if(isItTheExpectedKey) {\n            tryGulp(el);\n        }\n    }\n    function simulateSnake(el) {\n        var queue = key_queue;\n        var len = queue.length;\n        getDimensions(); //Get updated dimensions alwasy\n        if(len === 0) {\n            processGeneral(el, BODY_PART_SIZE);\n            //Not pressing any key means snake is moving in direction of last body_part\n            var last = body.querySelector(LAST_BODY_PART_SELECTOR);\n            var rotation = last.rotation;\n            var last_style = last.style;\n            // console.log(\"STYLE\", last_style)\n            var offset = BODY_PART_SIZE;//Need to adjust it\n            if(rotation === NEGATIVE_180_ROTATION) {\n                checkLeftCrash(last_style);\n            }\n            else if(rotation === ZERO_ROTATION) {\n                checkRightCrash(last_style, offset);\n            }\n            else if(rotation === POSITIVE_90_ROTATION) {\n                checkDownCrash(last_style, offset);\n            }\n            else if(rotation === NEGATIVE_90_ROTATION) {\n                checkUpCrash(last_style);\n            }\n            if(isDestroyed()) {\n                return;\n            }\n            checkOverlap(el);\n            tryGulp(el);\n        }\n        else {\n            processKeyEvent(el, queue.pop());\n        }\n    }\n    function keyEventListener(e) {\n        if(e.keyCode === LEFT_KEY_CODE ||e.keyCode === DOWN_KEY_CODE ||e.keyCode === UP_KEY_CODE ||e.keyCode === RIGHT_KEY_CODE ) {\n            e.preventDefault();\n            e.stopPropagation();\n            if(!isDestroyed() && !isEnded()) {\n                append(e.keyCode);\n            }\n        } else {\n            if(e.keyCode === ESCAPE_KEY_CODE) {\n                if(isDestroyed()) {\n                    return;\n                }\n                e.preventDefault();\n                e.stopPropagation();\n                killGame();\n            } else if(e.keyCode === SPACE_KEY_CODE) {\n                e.preventDefault();\n                e.stopPropagation();\n                if(isDestroyed() || isEnded()) {\n                    return;\n                }\n                if(snake.paused === true) {\n                    moveStateTo(STATES.RUNNING);\n                } else {\n                    moveStateTo(STATES.PAUSED);\n                }\n                snake.paused = toggle(snake.paused);\n            } else if(e.keyCode === R_KEY_CODE) {\n                e.preventDefault();\n                e.stopPropagation();\n                restartGame();\n            }\n        }\n    }\n    function start() {\n        snake.state = STATES.INITIALISING,\n        saveCurrentLayout();\n        modifyLayout();\n        setupPlayground();\n        getDimensions();\n        makeInitialSnake(snake_body);\n        markPoint(snake_body);\n        addKeyListener();\n    }\n    start();\n})();"]],"start1":3295,"start2":3295,"length1":16081,"length2":23131}]],"length":26426,"saved":false}
{"ts":1341729012615,"patch":[[{"diffs":[[0,"        "],[-1,"var "],[0,"iframe ="]],"start1":6152,"start2":6152,"length1":20,"length2":16}]],"length":26422,"saved":false}
{"ts":1341729029377,"patch":[[{"diffs":[[0,"_options"],[1,",\n        iframe"],[0,";\n    fu"]],"start1":2397,"start2":2397,"length1":16,"length2":32}]],"length":26438,"saved":false}
{"ts":1341729202554,"patch":[[{"diffs":[[0,"ame."],[-1,"setAttribute('id',IFRAME_ID)"],[1,"id = IFRAME_ID;\n        iframe.src = IFRAME_SRC"],[0,";\n  "]],"start1":6230,"start2":6230,"length1":36,"length2":55}]],"length":26457,"saved":false}
{"ts":1341729437215,"patch":[[{"diffs":[[0,"frame\",\n"],[1,"        IFRAME_SRC = \"http://c9.io/hariombalhara_1/snake/personalise.js\",\n"],[0,"        "]],"start1":1525,"start2":1525,"length1":16,"length2":90},{"diffs":[[0,"ME_SRC;\n"],[1,"        body.appendChild(iframe);\n"],[0,"    }\n  "]],"start1":6349,"start2":6349,"length1":16,"length2":50}]],"length":26565,"saved":false}
{"ts":1341729443034,"patch":[[{"diffs":[[0,"ise."],[-1,"js"],[1,"html"],[0,"\",\n "]],"start1":1598,"start2":1598,"length1":10,"length2":12}]],"length":26567,"saved":false}
