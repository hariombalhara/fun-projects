{"ts":1341845612336,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"(function main() {\n    \"use strict\";\n    var LEFT_KEY_CODE = 37,\n        UP_KEY_CODE = 38,\n        RIGHT_KEY_CODE = 39,\n        DOWN_KEY_CODE = 40,\n        ESCAPE_KEY_CODE = 27,\n        SPACE_KEY_CODE = 32,//TO PAUSE THE GAME\n        R_KEY_CODE = 82,//Restart\n        NO_OF_INITIAL_BODY_PARTS = 3,\n        POSITIVE_90_ROTATION = \"rotate(90deg)\",\n        NEGATIVE_90_ROTATION = \"rotate(-90deg)\",\n        NEGATIVE_180_ROTATION = \"rotate(-180deg)\",\n        ZERO_ROTATION = \"\",\n        BODY_PART_SIZE = 20, \n        SPEED = 60,\n        INCREASE_SIZE_BY = 1,\n        GULP_COUNTER_DIV_ID = 'snake_gulp_counter',\n        GULP_COUNTER_DIV_CLASS = 'snake_gulp_counter',\n        LAST_BODY_PART_SELECTOR = '#snake span:nth-last-child(1)',\n        SNAKE_FIGURE = '<svg xmlns = \"http://www.w3.org/2000/svg\" version=\"1.1\"><rect class=\"snake_figure\" id=\"snake_figure\" width=\"' + BODY_PART_SIZE + '\" height=\"' + BODY_PART_SIZE + '\"/></svg>',\n        PLAYGROUND_CLASS = 'snake_playground',\n        PLAYGROUND_ID = 'snake_playground',\n        SNAKE_BODY_CLASS = 'snake',\n        SNAKE_BODY_ID = 'snake',\n        SNAKE_BODY_PART_CLASS = 'snake_body_part',\n        SNAKE_BODY_PART_ID = 'snake_body_part',\n        GAME_STATE_CLASS = 'snake_state',\n        GAME_STATE_ID = 'snake_state',\n        GAME_STATE_HTML = '<b>PAUSED</b>',\n        CRASH_OPTIONS_CLASS = 'crash_options',\n        CRASH_OPTIONS_ID = 'crash_options',\n        CRASH_OPTIONS_HTML = \"Press <b><i>'r'</i></b> to Restart or <b><i>'Esc'</i></b> to Exit\",\n        IFRAME_ID = \"snake_iframe\",\n        IFRAME_SRC = \"http://php-hariombalhara.rhcloud.com/personalise.html\",\n        STATES = {\n            RUNNING: 0, \n            PAUSED: 1,\n            ENDED: 2, //Game has ended .But things are still there.\n            INITIALISING: 3,\n            DESTROYED: 4 //Games has ended and complete playground has been destroyed\n            },\n        body = document.body,\n        snake = window.snake = {},//Snake Namespace\n        point = snake.point = {},//Holds the position of the point.\n        orig_layout = snake.orig_layout = {},//It will hold the original style information for the page\n        key_queue = snake.key_queue = [],//Holds the keys to be processed\n        window_availWidth = -1,\n        window_availHeight = -1,\n        width = -1,\n        height = -1,\n        snake_playground = {},\n        snake_body = {},\n        state_of_game_el = {},\n        gulp_counter_el = {},\n        startover_max_counter = 0,\n        crash_options,\n        iframe;\n    function getIntPartFromStr(str) {\n        return parseInt(str, 10);\n    }\n    function isDestroyed() {\n        if (snake.state === STATES.DESTROYED) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function isEnded() {\n        if (snake.state === STATES.ENDED) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function copy_style(el, save_obj) {\n        var style = el.style,\n            obj_style = {},\n            i;\n        if (!save_obj.style) {\n            obj_style = save_obj.style = {};\n        } else {\n            obj_style = save_obj.style;\n        }\n        for (i in style) { //TODO:Need to be more specific cause style can have methods too.This is a very genric approach,can cause problem in future\n            obj_style[i] = style[i];\n        }\n    }\n    function toggle(boolvar)\n    {\n        if (typeof boolvar !== 'boolean') {\n            throw new Error('boolvar is not a bool');\n        }\n        if (boolvar === true)\n        {\n            boolvar = false;\n        } else {\n            boolvar = true;\n        }\n        return boolvar;\n    }\n    //Save the current style info in case something wrong happens or fore restoration\n    function saveCurrentLayout() {\n        var b = orig_layout.body = {};\n        b.style = {};\n        b.style.overflow = body.style.overflow;\n        b.style.margin = body.style.margin;\n        //copy_style(body, snake.orig_layout.body);\n    }\n    function modifyLayout() {\n        body.style.overflow = \"hidden\";\n        body.style.margin = \"0\";\n    }    \n    function moveStateTo(state) {\n        if (state === STATES.PAUSED) {\n            snake.state = state;\n            state_of_game_el.innerHTML = \"PAUSED\";\n            clearInterval(snake.interval);\n        } else if (state === STATES.ENDED) {\n            snake.state = state;\n            state_of_game_el.innerHTML = \"ENDED\";\n            clearInterval(snake.interval);\n        } else if (state == STATES.RUNNING) {\n            state_of_game_el.innerHTML = \"\";\n            snake.interval = setInterval(function() {simulateSnake(snake_body);}, SPEED);\n        }\n    }\n    function getDimensions() {\n        window_availWidth = snake_playground.offsetWidth;\n        window_availHeight = snake_playground.offsetHeight;\n        width = snake.width = Math.floor(window_availWidth-(window_availWidth%BODY_PART_SIZE));\n        height = snake.height = Math.floor(window_availHeight-(window_availHeight%BODY_PART_SIZE));\n    }\n    function appendChildWithInformation(child) {\n        var el = createSnakeElement(child);\n        this.appendChild(el);\n        return el;\n    }\n    function createSnakeElement(props) {\n        var el = document.createElement(props.tagName),\n            props_style=props.style;\n        if (props.className) {\n            el.setAttribute('class', props.className);\n        }\n        if (props.id) {\n            el.setAttribute('id', props.id);\n        }\n        if (props.innerHTML) {\n            el.innerHTML = props.innerHTML;\n        }\n        if ((typeof props_style) !== \"undefined\") {\n            if ((typeof props_style.left) !== \"undefined\") {\n                el.style.left = props.style.left;\n            }\n            if ((typeof props_style.top) !== \"undefined\") {\n                el.style.top = props.style.top;\n            }\n            if ((typeof props_style.height) !== \"undefined\") {\n                el.style.height = props.style.height;\n            }\n            if ((typeof props_style.width) !== \"undefined\") {\n                el.style.width = props.style.width;\n            }\n        }\n        el.appendChildWithInformation = appendChildWithInformation;\n        return el;\n    }\n    function insertFrame() {\n        iframe = document.createElement('iframe');\n        iframe.id = IFRAME_ID;\n        iframe.src = IFRAME_SRC;\n        snake_playground.appendChild(iframe);\n    }\n    function setupPlayground() {\n        snake_playground = createSnakeElement({\n            tagName: 'div',\n            className: PLAYGROUND_CLASS,\n            id: PLAYGROUND_ID,\n            style: {\n            height: \"100%\",\n            width: \"100%\"\n        }\n    });//Its the root element for the snake game\n        snake_body = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: SNAKE_BODY_CLASS,\n            id: SNAKE_BODY_ID,\n            style: {\n            }\n        });\n        gulp_counter_el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: GULP_COUNTER_DIV_CLASS,\n            id: GULP_COUNTER_DIV_ID,\n            innerHTML: '0'\n        });\n        state_of_game_el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: GAME_STATE_CLASS,\n            id: GAME_STATE_ID,\n            innerHTML: GAME_STATE_HTML\n        });\n        crash_options = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: CRASH_OPTIONS_CLASS,\n            id: CRASH_OPTIONS_ID,\n            innerHTML: CRASH_OPTIONS_HTML\n        });\n        //Finally append the snake playground to the body.\n        body.appendChild(snake_playground);\n        insertFrame();\n    }\n    function gulp(el, consume) {\n        var i;\n        if((typeof gulp.id) === \"undefined\") {\n            gulp.id=0;\n        }\n        if((typeof gulp.count) === \"undefined\") {\n            gulp.count=0;\n        }\n        if(consume === true) {\n            for (i = 0; i < INCREASE_SIZE_BY; i++) {\n                gulp.id+=1;\n                var offsetx=0;\n                var offsety=0;\n                var firstChild = el.childNodes[0];\n                var firstChild_style = firstChild.style;\n                var left = getIntPartFromStr(firstChild_style.left);\n                var top = getIntPartFromStr(firstChild_style.top);\n                var rotation = firstChild.rotation;\n                //The insertion philosophy is opposite to usual\n                if(rotation === NEGATIVE_180_ROTATION) {\n                    offsetx = BODY_PART_SIZE;\n                } else if(rotation === ZERO_ROTATION) {\n                    offsetx=-BODY_PART_SIZE;\n                } else if(rotation === POSITIVE_90_ROTATION) {\n                    offsety=-BODY_PART_SIZE;\n                } else if(rotation === NEGATIVE_90_ROTATION) {\n                    offsety = BODY_PART_SIZE;\n                }\n                if((offsetx === 0) && (offsety === 0)) {\n                    console.log(\"RAISE EXCEPTION HERE\");\n                }\n                var span = createSnakeElement({\n                    tagName: 'span',\n                    className: SNAKE_BODY_PART_CLASS,\n                    id: SNAKE_BODY_PART_ID+gulp.id,\n                    innerHTML: SNAKE_FIGURE,\n                    style: {\n                        left:left+offsetx+\"px\",\n                        top:top+offsety+\"px\"\n                    }\n                });\n                span.rotation = rotation;\n                el.insertBefore(span, el.childNodes[0]);\n            }\n            gulp.count+=1;\n            gulp_counter_el.innerHTML = gulp.count;\n        } else {\n            gulp.id+=1;\n            el.appendChildWithInformation.call(el, {\n                tagName:'span',\n                className:SNAKE_BODY_PART_CLASS,\n                id:SNAKE_BODY_PART_ID+gulp.id,\n                innerHTML:SNAKE_FIGURE,\n                style:{\n                    left:0,\n                    top:0\n                }\n            });\n        }\n    }\n    function makeInitialSnake(el) {\n        var i;\n        for (i = 0; i < NO_OF_INITIAL_BODY_PARTS; i++) {\n            gulp(el);\n            if(i >= 1 && (i <  NO_OF_INITIAL_BODY_PARTS)) {\n                el.childNodes[i].style.left=(getIntPartFromStr(el.childNodes[i].style.left)+(i*BODY_PART_SIZE))+\"px\";\n            }\n        }\n        snake.paused = true;\n    }\n    function restoreLayout() {\n        var b = orig_layout.body;\n        body.style.overflow = b.style.overflow;\n        body.style.margin = b.style.margin;\n    }\n    function markPoint(el) {\n        var x = -1,\n            y = -1,\n            count = 0,\n            len = el.childNodes.length;\n        while(true) {\n            var startover = false,\n                randx = Math.random(),\n                randy = Math.random(),\n                i;\n            x = (randx)*(getIntPartFromStr(width)-BODY_PART_SIZE);\n            y = (randy)*(getIntPartFromStr(height)-BODY_PART_SIZE);\n            x = x-(x%BODY_PART_SIZE);\n            y = y-(y%BODY_PART_SIZE);\n            for(i = 0; i < len-1; i++) {\n                var child = el.childNodes[i],\n                    child_style = child.style,\n                    top = child_style.top,\n                    left = child_style.left;\n                if((top === (y + \"px\")) && (left === (x + \"px\"))) {\n                    startover = true;\n                    if(startover_max_counter < count) {\n                        startover_max_counter = count;\n                        console.log(\"Startovercount highest value=\", startover_max_counter);\n                    }\n                    break;\n                }\n            }\n            if(!startover) {\n                break;\n            } else {\n                count++;\n            }\n        }\n        point.el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName:'div',\n            className:'snake_point',\n            id:'snake_point',\n            innerHTML:SNAKE_FIGURE,\n            style:{\n                left:x+\"px\",\n                top:y+\"px\"\n            }\n        });\n        //Store the position of the point in snake namespace for easy accessibilty\n        point.x = x;\n        point.y = y;\n    }\n    function append(keyCode) {\n        //FOR NOW ONLY THE LAST ELEMENT of QUEUE IS CONSIDERED\n        if(key_queue.length === 1) {\n            key_queue.shift();\n        }\n        key_queue.push(keyCode);\n    }\n    function addKeyListener() {\n        document.addEventListener(\"keydown\", keyEventListener, true);\n    }\n    function removeKeyListener() {\n        document.removeEventListener(\"keydown\", keyEventListener, true);\n    }\n    function freeze() {\n        clearInterval(snake.interval);\n        removeKeyListener();\n    }\n    function killGame() {\n        var script = document.getElementById('snake_script');\n        freeze();\n        try {\n            if(snake_playground) {\n                body.removeChild(snake_playground);\n            }\n        }\n        catch(e) {\n            console.log('Exception:', \"Caller is =\"+killGame.caller, \"ParentNode=\"+snake_playground.parentNode, \"Node=\"+snake_playground);\n        }\n        restoreLayout();\n        if(script)\n        document.getElementsByTagName('head')[0].removeChild(script);\n    }\n    function restartGame() {\n        killGame();\n        main();\n    }\n    function crashSnake() {\n        if(isDestroyed() || (snake.state === STATES.ENDED)) {\n            console.log('Crash Snake-STATE:',snake.state);\n            return;\n        }\n        crash_options.style.display = \"block\";\n        moveStateTo(STATES.ENDED)\n    }\n    function checkUpCrash(last_style) {\n        if((getIntPartFromStr(last_style.top)) < 0) {\n            crashSnake();\n        }\n    }\n    function checkLeftCrash(last_style) {\n        if((getIntPartFromStr(last_style.left)) < 0) {\n            crashSnake();\n        }\n    }\n    function checkRightCrash(last_style, offset) {\n        if((getIntPartFromStr(last_style.left)+offset) > width) {\n            crashSnake();\n        }\n    }\n    function checkDownCrash(last_style, offset) {\n        if((getIntPartFromStr(last_style.top)+offset) > height) {\n            crashSnake();\n        }\n    }\n    function processGeneral(element, distance, leave_last) {\n        //TODO: make a copy of node list as traversing it is costly.\n        var len = element.childNodes.length,\n            up_to = len,\n            i;\n        if(leave_last) {\n            up_to = len-1;\n        }\n        for(i = 0; i < up_to; i++) {\n            var child = element.childNodes[i],\n                child_style = child.style,\n                rotation,\n                rotation_flag = false,\n                lookahead_rotation_flag,\n                left_coordinate,\n                top_coordinate;\n            child.rotation=((typeof child.rotation) === \"undefined\")?ZERO_ROTATION:child.rotation;\n            rotation = child.rotation;            \n            if(child.rotation === POSITIVE_90_ROTATION || child.rotation === NEGATIVE_90_ROTATION) {\n                rotation_flag = true;\n            }\n            lookahead_rotation_flag=-1;\n            left_coordinate = getIntPartFromStr(child_style.left);\n            top_coordinate = getIntPartFromStr(child_style.top);\n            if(i+1 < len) {\n                if(element.childNodes[i+1].rotation === POSITIVE_90_ROTATION || element.childNodes[i+1].rotation === NEGATIVE_90_ROTATION) {\n                    lookahead_rotation_flag = true;\n                }\n                if(element.childNodes[i+1].rotation === ZERO_ROTATION || element.childNodes[i+1].rotation === NEGATIVE_180_ROTATION) {\n                    lookahead_rotation_flag = false;\n                }\n            }\n            if(((typeof rotation_flag) === \"undefined\") || (rotation_flag === false)) {\n                child.isRotated = false;\n                if(((typeof lookahead_rotation_flag) !== \"undefined\") && (lookahead_rotation_flag === true)) {\n                    child.isRotated = true;\n                    child.rotation = element.childNodes[i+1].rotation;\n                    //Simulate rotation\n                    if(child.rotation === NEGATIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate-(distance)) + \"px\";\n                    }\n                    if(child.rotation === POSITIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate+(distance)) + \"px\";\n                    }\n                } else {\n                    if(rotation === ZERO_ROTATION) {\n                        child_style.left = (left_coordinate+(distance)) + \"px\";\n                    } else if(rotation === NEGATIVE_180_ROTATION) {\n                        child_style.left = (left_coordinate-(distance)) + \"px\";\n                    }\n                }\n            }\n            else {//rotation flag is true\n                if(((typeof lookahead_rotation_flag) === \"undefined\") || (lookahead_rotation_flag === false)) {\n                    child.isRotated = false;\n                    child.rotation = element.childNodes[i+1].rotation;\n                    //Simulate rotation\n                    if(child.rotation === ZERO_ROTATION) {\n                        child_style.left = (left_coordinate + (distance)) + \"px\";\n                    }\n                    if(child.rotation === NEGATIVE_180_ROTATION) {\n                        child_style.left = (left_coordinate-(distance))+\"px\";\n                    }\n                }\n                else\n                {\n                    if(rotation === NEGATIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate-(distance))+'px';\n                    }\n                    else if(rotation === POSITIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate+(distance))+'px';\n                    }\n                }\n            }\n        }\n    }\n    function checkOverlap(el) {\n        //TODO:copy childnodes to an array cause domenodes processing is costly\n        var last = body.querySelector(LAST_BODY_PART_SELECTOR),\n            last_style = last.style,\n            last_style_top = last_style.top,\n            last_style_left = last_style.left,\n            len = el.childNodes.length,\n            i;\n        for(i = 0; i < len-1; i++) {\n            var child = el.childNodes[i],\n                child_style = child.style,\n                top = child_style.top,\n                left = child_style.left;\n            if((top === last_style_top) && (left === last_style_left)) {\n                crashSnake();\n            }\n        }\n    }\n    function tryGulp(el) {\n        var last = body.querySelector(LAST_BODY_PART_SELECTOR);\n        var last_style = last.style;\n        var last_style_top = last_style.top;\n        var last_style_left = last_style.left;\n        if(((snake.point.x+\"px\") === last_style_left) && ((snake.point.y+\"px\") === last_style_top)) {\n            snake_playground.removeChild(point.el);\n            gulp(el, true);\n            markPoint(el);\n        }\n    }\n    function processDownKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var top_coordinate = getIntPartFromStr(child_style.top);\n        var leave_last = false;\n        if((rotation === ZERO_ROTATION) || (rotation === NEGATIVE_180_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.top = (top_coordinate + (distance)) + \"px\";\n            element.childNodes[key].rotation = POSITIVE_90_ROTATION;\n        }\n    }\n    function processUpKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var top_coordinate = getIntPartFromStr(child_style.top);\n        var leave_last = false;\n        if((rotation === ZERO_ROTATION) || (rotation === NEGATIVE_180_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.top = (top_coordinate - (distance)) + \"px\";\n            element.childNodes[key].rotation = NEGATIVE_90_ROTATION;\n        }\n    }\n    function processRightKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var left_coordinate = getIntPartFromStr(child_style.left);\n        var leave_last = false;\n        if((rotation === POSITIVE_90_ROTATION) || (rotation === NEGATIVE_90_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.left = (left_coordinate + (distance)) + \"px\";\n            element.childNodes[key].rotation = ZERO_ROTATION;\n        }\n    }\n    function processLeftKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var left_coordinate = getIntPartFromStr(child_style.left);\n        var leave_last = false;\n        if((rotation === POSITIVE_90_ROTATION) || (rotation === NEGATIVE_90_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.left = (left_coordinate-(distance))+\"px\";\n            element.childNodes[key].rotation = NEGATIVE_180_ROTATION;\n        }\n    }\n    function processKeyEvent(el, keyCode) {\n        var no_of_child_nodes = el.childNodes.length;\n        var rotation = {};\n        rotation.value = el.childNodes[(no_of_child_nodes-1)].rotation;\n        el.childNodes[no_of_child_nodes-1].rotation = rotation.value = (typeof rotation.value === \"undefined\")?ZERO_ROTATION: rotation.value;\n        rotation.isNeg90 = (rotation.value === NEGATIVE_90_ROTATION );\n        rotation.isPos90 = (rotation.value === POSITIVE_90_ROTATION );\n        rotation.isNeg180=(rotation.value === NEGATIVE_180_ROTATION );\n        rotation.isZero = (rotation.value === ZERO_ROTATION );\n        var move_distance = BODY_PART_SIZE;\n        var last = document.body.querySelector(LAST_BODY_PART_SELECTOR);\n        var last_style = last.style;\n        var offset = BODY_PART_SIZE;\n        var isItTheExpectedKey = true;\n        switch(keyCode) {\n            case LEFT_KEY_CODE:\n                if(rotation.isNeg90 || rotation.isPos90 || rotation.isNeg180) {\n                    processLeftKey(el, move_distance);\n                    checkLeftCrash(last_style);\n                }\n                break;\n            case UP_KEY_CODE:\n                if(rotation.isNeg90 ||rotation.isZero || rotation.isNeg180) {\n                    processUpKey(el, move_distance);\n                    checkUpCrash(last_style);\n                }\n                break;\n            case RIGHT_KEY_CODE:\n                if(rotation.isPos90 || rotation.isZero || rotation.isNeg90) {\n                    processRightKey(el, move_distance);\n                    checkRightCrash(last_style, offset);\n                }\n                break;\n            case DOWN_KEY_CODE:\n                if(rotation.isPos90 || rotation.isZero || rotation.isNeg180) {\n                    processDownKey(el, move_distance);\n                    checkDownCrash(last_style, offset);\n                }\n                break;\n            default:\n                isItTheExpectedKey = false;\n                alert('Unexpected key');\n        }\n        if(isItTheExpectedKey) {\n            tryGulp(el);\n        }\n    }\n    function simulateSnake(el) {\n        var queue = key_queue;\n        var len = queue.length;\n        getDimensions(); //Get updated dimensions alwasy\n        if(len === 0) {\n            processGeneral(el, BODY_PART_SIZE);\n            //Not pressing any key means snake is moving in direction of last body_part\n            var last = body.querySelector(LAST_BODY_PART_SELECTOR);\n            var rotation = last.rotation;\n            var last_style = last.style;\n            // console.log(\"STYLE\", last_style)\n            var offset = BODY_PART_SIZE;//Need to adjust it\n            if(rotation === NEGATIVE_180_ROTATION) {\n                checkLeftCrash(last_style);\n            }\n            else if(rotation === ZERO_ROTATION) {\n                checkRightCrash(last_style, offset);\n            }\n            else if(rotation === POSITIVE_90_ROTATION) {\n                checkDownCrash(last_style, offset);\n            }\n            else if(rotation === NEGATIVE_90_ROTATION) {\n                checkUpCrash(last_style);\n            }\n            if(isDestroyed()) {\n                return;\n            }\n            checkOverlap(el);\n            tryGulp(el);\n        }\n        else {\n            processKeyEvent(el, queue.pop());\n        }\n    }\n\n    function postToHostingSite(container) {\n        //TODO:Put Restriction here for target ORigin\n        console.log('POSTING MESSAGE to Game Host'+iframe);\n        iframe.contentWindow.postMessage(container,'*');\n    }\n    function saveScore() {\n        var container = {\n            score:gulp_counter_el.innerHTML\n        }\n        postToHostingSite(container);\n    }\n    function keyEventListener(e) {\n        if(e.keyCode === LEFT_KEY_CODE ||e.keyCode === DOWN_KEY_CODE ||e.keyCode === UP_KEY_CODE ||e.keyCode === RIGHT_KEY_CODE ) {\n            e.preventDefault();\n            e.stopPropagation();\n            if(!isDestroyed() && !isEnded()) {\n                append(e.keyCode);\n            }\n        } else {\n            if(e.keyCode === ESCAPE_KEY_CODE) {\n                if(isDestroyed()) {\n                    return;\n                }\n                e.preventDefault();\n                e.stopPropagation();\n                saveScore();\n                killGame();\n            } else if(e.keyCode === SPACE_KEY_CODE) {\n                e.preventDefault();\n                e.stopPropagation();\n                if(isDestroyed() || isEnded()) {\n                    return;\n                }\n                if(snake.paused === true) {\n                    moveStateTo(STATES.RUNNING);\n                } else {\n                    moveStateTo(STATES.PAUSED);\n                }\n                snake.paused = toggle(snake.paused);\n            } else if(e.keyCode === R_KEY_CODE) {\n                e.preventDefault();\n                e.stopPropagation();\n                restartGame();\n            }\n        }\n    }\n    \n    \n    function personaliseGame() {\n         window.onmessage = function(e) {\n            //TODO: Put restrictions somehow on which origin is accepted\n            console.log(\"ONMESSAGE EVENT\");\n            if(e.data.score !== -1)\n            gulp_counter_el.innerHTML = e.data.score\n            document.title =\"Hi \"+e.data.email;\n        }\n    }\n    function start() {\n        snake.state = STATES.INITIALISING,\n        saveCurrentLayout();\n        modifyLayout();\n        setupPlayground();\n        getDimensions();\n        makeInitialSnake(snake_body);\n        markPoint(snake_body);\n        addKeyListener();\n        personaliseGame();\n    }\n    start();\n})();"]],"start1":0,"start2":0,"length1":0,"length2":27366}]],"length":27366}
{"contributors":[],"silentsave":false,"ts":1342176801427,"patch":[[{"diffs":[[1,"(function main() {\n    \"use strict\";\n    var LEFT_KEY_CODE = 37,\n        UP_KEY_CODE = 38,\n        RIGHT_KEY_CODE = 39,\n        DOWN_KEY_CODE = 40,\n        ESCAPE_KEY_CODE = 27,\n        SPACE_KEY_CODE = 32,//TO PAUSE THE GAME\n        RESTART_KEY_CODE = 82,//R KEY\n        SAVE_KEY_CODE = 113,//F2 KEY\n        NO_OF_INITIAL_BODY_PARTS = 3,\n        POSITIVE_90_ROTATION = \"rotate(90deg)\",\n        NEGATIVE_90_ROTATION = \"rotate(-90deg)\",\n        NEGATIVE_180_ROTATION = \"rotate(-180deg)\",\n        ZERO_ROTATION = \"\",\n        BODY_PART_SIZE = 20, \n        SPEED = 60,\n        INCREASE_SIZE_BY = 1,\n        GULP_COUNTER_DIV_ID = 'snake_gulp_counter',\n        GULP_COUNTER_DIV_CLASS = 'snake_gulp_counter',\n        LAST_BODY_PART_SELECTOR = '#snake span:nth-last-child(1)',\n        SNAKE_FIGURE = '<svg xmlns = \"http://www.w3.org/2000/svg\" version=\"1.1\"><rect class=\"snake_figure\" id=\"snake_figure\" width=\"' + BODY_PART_SIZE + '\" height=\"' + BODY_PART_SIZE + '\"/></svg>',\n        PLAYGROUND_CLASS = 'snake_playground',\n        PLAYGROUND_ID = 'snake_playground',\n        SNAKE_BODY_CLASS = 'snake',\n        SNAKE_BODY_ID = 'snake',\n        SNAKE_BODY_PART_CLASS = 'snake_body_part',\n        SNAKE_BODY_PART_ID = 'snake_body_part',\n        GAME_STATE_CLASS = 'snake_state',\n        GAME_STATE_ID = 'snake_state',\n        GAME_STATE_HTML = '<b>PAUSED</b>',\n        CRASH_OPTIONS_CLASS = 'crash_options',\n        CRASH_OPTIONS_ID = 'crash_options',\n        CRASH_OPTIONS_HTML = \"Press <b><i>'r'</i></b> to Restart or <b><i>'Esc'</i></b> to Exit\",\n        IFRAME_ID = \"snake_iframe\",\n        IFRAME_SRC = \"http://php-hariombalhara.rhcloud.com/personalise.html\",\n        STATES = {\n            RUNNING: 0, \n            PAUSED: 1,\n            ENDED: 2, //Game has ended .But things are still there.\n            INITIALISING: 3,\n            DESTROYED: 4 //Games has ended and complete playground has been destroyed\n            },\n        MSG_TYPE = { //It has a duplicate in personalise.js\n            UPLOAD_DATA: 'UPLOAD_DATA', //Right Now its just the score\n            DATABASE_UPDATED: 'DATABASE_UPDATED',\n            UPDATE_PAGE: 'UPDATE_PAGE',\n            INITIATE_LOGIN: 'INITIATE_LOGIN',\n            INITIALIZE_HOST_PAGE: 'INITIALIZE_HOST_PAGE'\n        },\n        MODE = { //It has duplicate in personalise.js\n            SAVE_KILL: 0,\n            SAVE: 1,\n            SAVE_KILL_RESTART:2\n        },\n        body = document.body,\n        snake = window.snake = {},//Snake Namespace\n        point = snake.point = {},//Holds the position of the point.\n        original_cfg = snake.original_cfg = {},//It will hold the original style information for the page\n        key_queue = snake.key_queue = [],//Holds the keys to be processed\n        window_availWidth = -1,\n        window_availHeight = -1,\n        width = -1,\n        height = -1,\n        snake_playground = {},\n        snake_body = {},\n        state_of_game_el = {},\n        gulp_counter_el = {},\n        startover_max_counter = 0,\n        noSignIn = false,\n        crash_options,\n        iframe,\n        login_el,\n        loggedIn,\n        body_map = [];\n    function getIntPartFromStr(str) {\n        return parseInt(str, 10);\n    }\n    function isDestroyed() {\n        if (snake.state === STATES.DESTROYED) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function isEnded() {\n        if (snake.state === STATES.ENDED) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function copy_style(el, save_obj) {\n        var style = el.style,\n            obj_style = {},\n            i;\n        if (!save_obj.style) {\n            obj_style = save_obj.style = {};\n        } else {\n            obj_style = save_obj.style;\n        }\n        for (i in style) { //TODO:Need to be more specific cause style can have methods too.This is a very genric approach,can cause problem in future\n            obj_style[i] = style[i];\n        }\n    }\n    function toggle(boolvar)\n    {\n        if (typeof boolvar !== 'boolean') {\n            throw new Error('boolvar is not a bool');\n        }\n        if (boolvar === true)\n        {\n            boolvar = false;\n        } else {\n            boolvar = true;\n        }\n        return boolvar;\n    }\n    //Save the current style info in case something wrong happens or fore restoration\n    function saveCurrentCfg() {\n        var b = original_cfg.body = {};\n        b.style = {};\n        b.style.overflow = body.style.overflow;\n        b.style.margin = body.style.margin;\n        original_cfg.document={title:document.title};\n        b.onbeforeunload = body.onbeforeunload; //TODO:Test it by attaching an onbeforeunload function to body on original site.\n        //copy_style(body, snake.original_cfg.body);\n    }\n    function actonbeforeunload() {\n      return 'Unsaved Changes';//Not shown\n    }\n    function modifyCfg() {\n        body.style.overflow = \"hidden\";\n        body.style.margin = \"0\";\n        body.onbeforeunload = actonbeforeunload;\n    }    \n    function moveStateTo(state) {\n        if (state === STATES.PAUSED) {\n            snake.state = state;\n            state_of_game_el.innerHTML = \"PAUSED\";\n            clearInterval(snake.interval);\n        } else if (state === STATES.ENDED) {\n            snake.state = state;\n            state_of_game_el.innerHTML = \"ENDED\";\n            clearInterval(snake.interval);\n        } else if (state == STATES.RUNNING) {\n            state_of_game_el.innerHTML = \"\";\n            snake.interval = setInterval(function() {simulateSnake(snake_body);}, SPEED);\n        }\n    }\n    function getDimensions() {\n        window_availWidth = snake_playground.offsetWidth;\n        window_availHeight = snake_playground.offsetHeight;\n        width = snake.width = Math.floor(window_availWidth-(window_availWidth%BODY_PART_SIZE));\n        height = snake.height = Math.floor(window_availHeight-(window_availHeight%BODY_PART_SIZE));\n    }\n    function appendChildWithInformation(child) {\n        var el = createSnakeElement(child);\n        this.appendChild(el);\n        return el;\n    }\n    function createSnakeElement(props) {\n        var el = document.createElement(props.tagName),\n            props_style=props.style;\n        if (props.className) {\n            el.setAttribute('class', props.className);\n        }\n        if (props.id) {\n            el.setAttribute('id', props.id);\n        }\n        if (props.innerHTML) {\n            el.innerHTML = props.innerHTML;\n        }\n        if ((typeof props_style) !== \"undefined\") {\n            if ((typeof props_style.left) !== \"undefined\") {\n                el.style.left = props.style.left;\n            }\n            if ((typeof props_style.top) !== \"undefined\") {\n                el.style.top = props.style.top;\n            }\n            if ((typeof props_style.height) !== \"undefined\") {\n                el.style.height = props.style.height;\n            }\n            if ((typeof props_style.width) !== \"undefined\") {\n                el.style.width = props.style.width;\n            }\n        }\n        el.appendChildWithInformation = appendChildWithInformation;\n        return el;\n    }\n    function insertFrame() {\n        iframe = document.createElement('iframe');\n        iframe.id = IFRAME_ID;\n        iframe.src = IFRAME_SRC;\n        snake_playground.appendChild(iframe);\n    }\n\n    function init_persona_login(e) {\n        e.preventDefault();\n        var container = {\n            msgType:MSG_TYPE.INITIATE_LOGIN\n        };\n       postToHostingSite(container);\n    }\n    function continueAsGuest() {\n        login_el.style.display = \"none\";\n        noSignIn = true;\n    }\n    function updateLoginButton() {\n        var login_anchor=document.createElement('a');\n        var nologin_anchor=document.createElement('a');\n        login_anchor.onclick = init_persona_login;\n        login_anchor.href = \"javascript:void(null)\";\n        nologin_anchor.href = \"javascript:void(null)\";\n        nologin_anchor.innerHTML = \"OR &nbsp;&nbsp;GuestIn\";\n        nologin_anchor.onclick = continueAsGuest;\n        login_el.setAttribute('class','login_snake_game');\n        login_el.appendChild(login_anchor);\n        login_el.appendChild(nologin_anchor);\n    }\n    function insertLoginButton() {\n        login_el=document.createElement('div');\n        login_el.id = \"login_snake_game\";\n        login_el.setAttribute('class',\"login_snake_game\");\n        login_el.setAttribute('class',login_el.getAttribute('class')+\" waiting\");\n        snake_playground.appendChild(login_el);\n    }\n    function setupPlayground() {\n        snake_playground = createSnakeElement({\n            tagName: 'div',\n            className: PLAYGROUND_CLASS,\n            id: PLAYGROUND_ID,\n            style: {\n            height: \"100%\",\n            width: \"100%\"\n        }\n    });//Its the root element for the snake game\n        snake_body = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: SNAKE_BODY_CLASS,\n            id: SNAKE_BODY_ID,\n            style: {\n            }\n        });\n        gulp_counter_el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: GULP_COUNTER_DIV_CLASS,\n            id: GULP_COUNTER_DIV_ID,\n            innerHTML: '0'\n        });\n        state_of_game_el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: GAME_STATE_CLASS,\n            id: GAME_STATE_ID,\n            innerHTML: GAME_STATE_HTML\n        });\n        crash_options = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: CRASH_OPTIONS_CLASS,\n            id: CRASH_OPTIONS_ID,\n            innerHTML: CRASH_OPTIONS_HTML\n        });\n        //Finally append the snake playground to the body.\n        body.appendChild(snake_playground);\n        insertLoginButton();\n        insertFrame();\n        \n    }\n    function gulp(el, consume) {\n        var i;\n        if((typeof gulp.id) === \"undefined\") {\n            gulp.id=0;\n        }\n        if((typeof gulp.count) === \"undefined\") {\n            gulp.count=0;\n        }\n        if(consume === true) {\n            for (i = 0; i < INCREASE_SIZE_BY; i++) {\n                gulp.id+=1;\n                var offsetx=0;\n                var offsety=0;\n                var firstChild = el.childNodes[0];\n                var firstChild_style = firstChild.style;\n                var left = getIntPartFromStr(firstChild_style.left);\n                var top = getIntPartFromStr(firstChild_style.top);\n                var rotation = firstChild.rotation;\n                //The insertion philosophy is opposite to usual\n                if(rotation === NEGATIVE_180_ROTATION) {\n                    offsetx = BODY_PART_SIZE;\n                } else if(rotation === ZERO_ROTATION) {\n                    offsetx=-BODY_PART_SIZE;\n                } else if(rotation === POSITIVE_90_ROTATION) {\n                    offsety=-BODY_PART_SIZE;\n                } else if(rotation === NEGATIVE_90_ROTATION) {\n                    offsety = BODY_PART_SIZE;\n                }\n                if((offsetx === 0) && (offsety === 0)) {\n                    console.log(\"RAISE EXCEPTION HERE\");\n                }\n                var span = createSnakeElement({\n                    tagName: 'span',\n                    className: SNAKE_BODY_PART_CLASS,\n                    id: SNAKE_BODY_PART_ID+gulp.id,\n                    innerHTML: SNAKE_FIGURE,\n                    style: {\n                        left:left+offsetx+\"px\",\n                        top:top+offsety+\"px\"\n                    }\n                });\n                span.rotation = rotation;\n                el.insertBefore(span, el.childNodes[0]);\n            }\n            gulp.count+=1;\n            gulp_counter_el.innerHTML = gulp.count;\n        } else {\n            gulp.id+=1;\n            el.appendChildWithInformation.call(el, {\n                tagName:'span',\n                className:SNAKE_BODY_PART_CLASS,\n                id:SNAKE_BODY_PART_ID+gulp.id,\n                innerHTML:SNAKE_FIGURE,\n                style:{\n                    left:0,\n                    top:0\n                }\n            });\n        }\n    }\n    function makeInitialSnake(el) {\n        var i;\n        for (i = 0; i < NO_OF_INITIAL_BODY_PARTS; i++) {\n            gulp(el);\n            if(i >= 1 && (i <  NO_OF_INITIAL_BODY_PARTS)) {\n                el.childNodes[i].style.left=(getIntPartFromStr(el.childNodes[i].style.left)+(i*BODY_PART_SIZE))+\"px\";\n            }\n        }\n        snake.paused = true;\n    }\n    function restoreCfg() {\n        var b = original_cfg.body;\n        body.style.overflow = b.style.overflow;\n        body.style.margin = b.style.margin;\n        document.title = original_cfg.document.title;\n        body.onbeforeunload = b.onbeforeunload;\n    }\n    function markPoint(el) {\n        var x = -1,\n            y = -1,\n            count = 0,\n            len = el.childNodes.length;\n        while(true) {\n            var startover = false,\n                randx = Math.random(),\n                randy = Math.random(),\n                i;\n            x = (randx)*(getIntPartFromStr(width)-BODY_PART_SIZE);\n            y = (randy)*(getIntPartFromStr(height)-BODY_PART_SIZE);\n            x = x-(x%BODY_PART_SIZE);\n            y = y-(y%BODY_PART_SIZE);\n            for(i = 0; i < len-1; i++) {\n                var child = el.childNodes[i],\n                    child_style = child.style,\n                    top = child_style.top,\n                    left = child_style.left;\n                if((top === (y + \"px\")) && (left === (x + \"px\"))) {\n                    startover = true;\n                    if(startover_max_counter < count) {\n                        startover_max_counter = count;\n                        console.log(\"Startovercount highest value=\", startover_max_counter);\n                    }\n                    break;\n                }\n            }\n            if(!startover) {\n                break;\n            } else {\n                count++;\n            }\n        }\n        point.el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName:'div',\n            className:'snake_point',\n            id:'snake_point',\n            innerHTML:SNAKE_FIGURE,\n            style:{\n                left:x+\"px\",\n                top:y+\"px\"\n            }\n        });\n        //Store the position of the point in snake namespace for easy accessibilty\n        point.x = x;\n        point.y = y;\n    }\n    function append(keyCode) {\n        //FOR NOW ONLY THE LAST ELEMENT of QUEUE IS CONSIDERED\n        if(key_queue.length === 1) {\n            key_queue.shift();\n        }\n        key_queue.push(keyCode);\n    }\n    function addKeyListener() {\n        document.addEventListener(\"keydown\", keyEventListener, true);\n    }\n    function removeKeyListener() {\n        document.removeEventListener(\"keydown\", keyEventListener, true);\n    }\n    function freeze() {\n        clearInterval(snake.interval);\n        removeKeyListener();\n    }\n    function killGame() {\n        var script = document.getElementById('snake_script');\n        freeze();\n        try {\n            if(snake_playground) {\n                body.removeChild(snake_playground);\n            }\n        }\n        catch(e) {\n            console.log('Exception:', \"ParentNode=\"+snake_playground.parentNode, \"Node=\"+snake_playground);\n        }\n        restoreCfg();\n        if(script)\n        document.getElementsByTagName('head')[0].removeChild(script);\n    }\n    function restartGame() {\n        saveScore(MODE.SAVE_KILL_RESTART);\n    }\n    function crashSnake() {\n        if(isDestroyed() || (snake.state === STATES.ENDED)) {\n            console.log('Crash Snake-STATE:',snake.state);\n            return;\n        }\n        crash_options.style.display = \"block\";\n        moveStateTo(STATES.ENDED);\n    }\n    function checkUpCrash(last_style) {\n        if((getIntPartFromStr(last_style.top)) < 0) {\n            crashSnake();\n        }\n    }\n    function checkLeftCrash(last_style) {\n        if((getIntPartFromStr(last_style.left)) < 0) {\n            crashSnake();\n        }\n    }\n    function checkRightCrash(last_style, offset) {\n        if((getIntPartFromStr(last_style.left)+offset) > width) {\n            crashSnake();\n        }\n    }\n    function checkDownCrash(last_style, offset) {\n        if((getIntPartFromStr(last_style.top)+offset) > height) {\n            crashSnake();\n        }\n    }\n    function processGeneral(element, distance, leave_last) {\n        //TODO: make a copy of node list as traversing it is costly.\n        var len = element.childNodes.length,\n            up_to = len,\n            i;\n        if(leave_last) {\n            up_to = len-1;\n        }\n        for(i = 0; i < up_to; i++) {\n            var child = element.childNodes[i],\n                child_style = child.style,\n                rotation,\n                rotation_flag = false,\n                lookahead_rotation_flag,\n                left_coordinate,\n                top_coordinate;\n            child.rotation=((typeof child.rotation) === \"undefined\")?ZERO_ROTATION:child.rotation;\n            rotation = child.rotation;            \n            if(child.rotation === POSITIVE_90_ROTATION || child.rotation === NEGATIVE_90_ROTATION) {\n                rotation_flag = true;\n            }\n            lookahead_rotation_flag=-1;\n            left_coordinate = getIntPartFromStr(child_style.left);\n            top_coordinate = getIntPartFromStr(child_style.top);\n            if(i+1 < len) {\n                if(element.childNodes[i+1].rotation === POSITIVE_90_ROTATION || element.childNodes[i+1].rotation === NEGATIVE_90_ROTATION) {\n                    lookahead_rotation_flag = true;\n                }\n                if(element.childNodes[i+1].rotation === ZERO_ROTATION || element.childNodes[i+1].rotation === NEGATIVE_180_ROTATION) {\n                    lookahead_rotation_flag = false;\n                }\n            }\n            if(((typeof rotation_flag) === \"undefined\") || (rotation_flag === false)) {\n                child.isRotated = false;\n                if(((typeof lookahead_rotation_flag) !== \"undefined\") && (lookahead_rotation_flag === true)) {\n                    child.isRotated = true;\n                    child.rotation = element.childNodes[i+1].rotation;\n                    //Simulate rotation\n                    if(child.rotation === NEGATIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate-(distance)) + \"px\";\n                    }\n                    if(child.rotation === POSITIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate+(distance)) + \"px\";\n                    }\n                } else {\n                    if(rotation === ZERO_ROTATION) {\n                        child_style.left = (left_coordinate+(distance)) + \"px\";\n                    } else if(rotation === NEGATIVE_180_ROTATION) {\n                        child_style.left = (left_coordinate-(distance)) + \"px\";\n                    }\n                }\n            }\n            else {//rotation flag is true\n                if(((typeof lookahead_rotation_flag) === \"undefined\") || (lookahead_rotation_flag === false)) {\n                    child.isRotated = false;\n                    child.rotation = element.childNodes[i+1].rotation;\n                    //Simulate rotation\n                    if(child.rotation === ZERO_ROTATION) {\n                        child_style.left = (left_coordinate + (distance)) + \"px\";\n                    }\n                    if(child.rotation === NEGATIVE_180_ROTATION) {\n                        child_style.left = (left_coordinate-(distance))+\"px\";\n                    }\n                }\n                else\n                {\n                    if(rotation === NEGATIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate-(distance))+'px';\n                    }\n                    else if(rotation === POSITIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate+(distance))+'px';\n                    }\n                }\n            }\n        }\n    }\n    function checkOverlap(el) {\n        //TODO:copy childnodes to an array cause domenodes processing is costly\n        var last = body.querySelector(LAST_BODY_PART_SELECTOR),\n            last_style = last.style,\n            last_style_top = last_style.top,\n            last_style_left = last_style.left,\n            len = el.childNodes.length,\n            i;\n        for(i = 0; i < len-1; i++) {\n            var child = el.childNodes[i],\n                child_style = child.style,\n                top = child_style.top,\n                left = child_style.left;\n            if((top === last_style_top) && (left === last_style_left)) {\n                crashSnake();\n            }\n        }\n    }\n    function tryGulp(el) {\n        var last = body.querySelector(LAST_BODY_PART_SELECTOR);\n        var last_style = last.style;\n        var last_style_top = last_style.top;\n        var last_style_left = last_style.left;\n        if(((snake.point.x+\"px\") === last_style_left) && ((snake.point.y+\"px\") === last_style_top)) {\n            snake_playground.removeChild(point.el);\n            gulp(el, true);\n            markPoint(el);\n        }\n    }\n    function processDownKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var top_coordinate = getIntPartFromStr(child_style.top);\n        var leave_last = false;\n        if((rotation === ZERO_ROTATION) || (rotation === NEGATIVE_180_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.top = (top_coordinate + (distance)) + \"px\";\n            element.childNodes[key].rotation = POSITIVE_90_ROTATION;\n        }\n    }\n    function processUpKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var top_coordinate = getIntPartFromStr(child_style.top);\n        var leave_last = false;\n        if((rotation === ZERO_ROTATION) || (rotation === NEGATIVE_180_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.top = (top_coordinate - (distance)) + \"px\";\n            element.childNodes[key].rotation = NEGATIVE_90_ROTATION;\n        }\n    }\n    function processRightKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var left_coordinate = getIntPartFromStr(child_style.left);\n        var leave_last = false;\n        if((rotation === POSITIVE_90_ROTATION) || (rotation === NEGATIVE_90_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.left = (left_coordinate + (distance)) + \"px\";\n            element.childNodes[key].rotation = ZERO_ROTATION;\n        }\n    }\n    function processLeftKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var left_coordinate = getIntPartFromStr(child_style.left);\n        var leave_last = false;\n        if((rotation === POSITIVE_90_ROTATION) || (rotation === NEGATIVE_90_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.left = (left_coordinate-(distance))+\"px\";\n            element.childNodes[key].rotation = NEGATIVE_180_ROTATION;\n        }\n    }\n    function processKeyEvent(el, keyCode) {\n        var no_of_child_nodes = el.childNodes.length;\n        var rotation = {};\n        rotation.value = el.childNodes[(no_of_child_nodes-1)].rotation;\n        el.childNodes[no_of_child_nodes-1].rotation = rotation.value = (typeof rotation.value === \"undefined\")?ZERO_ROTATION: rotation.value;\n        rotation.isNeg90 = (rotation.value === NEGATIVE_90_ROTATION );\n        rotation.isPos90 = (rotation.value === POSITIVE_90_ROTATION );\n        rotation.isNeg180=(rotation.value === NEGATIVE_180_ROTATION );\n        rotation.isZero = (rotation.value === ZERO_ROTATION );\n        var move_distance = BODY_PART_SIZE;\n        var last = document.body.querySelector(LAST_BODY_PART_SELECTOR);\n        var last_style = last.style;\n        var offset = BODY_PART_SIZE;\n        var isItTheExpectedKey = true;\n        switch(keyCode) {\n            case LEFT_KEY_CODE:\n                if(rotation.isNeg90 || rotation.isPos90 || rotation.isNeg180) {\n                    processLeftKey(el, move_distance);\n                    checkLeftCrash(last_style);\n                }\n                break;\n            case UP_KEY_CODE:\n                if(rotation.isNeg90 ||rotation.isZero || rotation.isNeg180) {\n                    processUpKey(el, move_distance);\n                    checkUpCrash(last_style);\n                }\n                break;\n            case RIGHT_KEY_CODE:\n                if(rotation.isPos90 || rotation.isZero || rotation.isNeg90) {\n                    processRightKey(el, move_distance);\n                    checkRightCrash(last_style, offset);\n                }\n                break;\n            case DOWN_KEY_CODE:\n                if(rotation.isPos90 || rotation.isZero || rotation.isNeg180) {\n                    processDownKey(el, move_distance);\n                    checkDownCrash(last_style, offset);\n                }\n                break;\n            default:\n                isItTheExpectedKey = false;\n                alert('Unexpected key');\n        }\n        if(isItTheExpectedKey) {\n            tryGulp(el);\n        }\n    }\n    function simulateSnake(el) {\n        var queue = key_queue;\n        var len = queue.length;\n        getDimensions(); //Get updated dimensions alwasy\n        if(len === 0) {\n            processGeneral(el, BODY_PART_SIZE);\n            //Not pressing any key means snake is moving in direction of last body_part\n            var last = body.querySelector(LAST_BODY_PART_SELECTOR);\n            var rotation = last.rotation;\n            var last_style = last.style;\n            // console.log(\"STYLE\", last_style)\n            var offset = BODY_PART_SIZE;//Need to adjust it\n            if(rotation === NEGATIVE_180_ROTATION) {\n                checkLeftCrash(last_style);\n            }\n            else if(rotation === ZERO_ROTATION) {\n                checkRightCrash(last_style, offset);\n            }\n            else if(rotation === POSITIVE_90_ROTATION) {\n                checkDownCrash(last_style, offset);\n            }\n            else if(rotation === NEGATIVE_90_ROTATION) {\n                checkUpCrash(last_style);\n            }\n            if(isDestroyed()) {\n                return;\n            }\n            checkOverlap(el);\n            tryGulp(el);\n        }\n        else {\n            processKeyEvent(el, queue.pop());\n        }\n    }\n\n    function postToHostingSite(container) {\n        //TODO:Put Restriction here for target ORigin\n        console.log('POSTING MESSAGE to Game Host'+iframe);\n        iframe.contentWindow.postMessage(container,'*');\n    }\n    function saveScore(mode) {\n        var container = {\n            msgType: MSG_TYPE.UPLOAD_DATA,\n            score: gulp_counter_el.innerHTML,\n            mode:mode\n        };\n        if(mode != MODE.SAVE)\n        snake_playground.style.display = \"none\";//Set Display to none to make it look like the game is killed instantly.\n        postToHostingSite(container);\n    }\n    function keyEventListener(e) {\n        if((noSignIn || loggedIn)&&(e.keyCode === LEFT_KEY_CODE ||e.keyCode === DOWN_KEY_CODE ||e.keyCode === UP_KEY_CODE ||e.keyCode === RIGHT_KEY_CODE )) {\n            e.preventDefault();\n            e.stopPropagation();\n            if(!isDestroyed() && !isEnded()) {\n                append(e.keyCode);\n            }\n        } else {\n            if(e.keyCode === ESCAPE_KEY_CODE) {\n                if(isDestroyed()) {\n                    return;\n                }\n                e.preventDefault();\n                e.stopPropagation();\n                saveScore(MODE.SAVE_KILL);\n                //killGame();Game will be killed when a message is received that score is updated to database\n            } else if((noSignIn || loggedIn)&&(e.keyCode === SPACE_KEY_CODE)) {\n                e.preventDefault();\n                e.stopPropagation();\n                if(isDestroyed() || isEnded()) {\n                    return;\n                }\n                if(snake.paused === true) {\n                    moveStateTo(STATES.RUNNING);\n                } else {\n                    moveStateTo(STATES.PAUSED);\n                }\n                snake.paused = toggle(snake.paused);\n            } else if((noSignIn || loggedIn)&&(e.keyCode === RESTART_KEY_CODE)) {\n                e.preventDefault();\n                e.stopPropagation();\n                restartGame();\n            } else if((noSignIn || loggedIn)&&(e.keyCode === SAVE_KEY_CODE)) {\n                e.preventDefault();\n                e.stopPropagation();\n                saveScore(MODE.SAVE);\n            }\n        }\n    }\n    function personaliseGame() {\n         window.onmessage = function(e) {\n            var container = e.data,\n                data;\n            //TODO: Put restrictions somehow on which origin is accepted\n            console.log(\"ONMESSAGE EVENT received on Parent\");\n            if(container.msgType === MSG_TYPE.DATABASE_UPDATED) {\n                console.log('Received DATABASE_UDPATED.Killing Now');\n                if(container.mode === MODE.SAVE_KILL) {\n                    killGame();\n                } else if(container.mode === MODE.SAVE_KILL_RESTART) {\n                    killGame();\n                    main();\n                }\n            }\n            else if(container.msgType === MSG_TYPE.UPDATE_PAGE) {\n                data = container.data;\n                if(data.highestScore !== '-1') {\n                    gulp_counter_el.innerHTML = data.highestScore;\n                }\n                login_el.style.display = \"none\";\n                document.title = \"Hi \"+data.email+\"(\"+data.name+\")\";\n                if(data.uuid) {\n                    loggedIn = true;\n                }\n                console.log('KNOWN USER1'+data.uuid);\n            } else if(container.msgType === MSG_TYPE.INITIALIZE_HOST_PAGE) {\n                var uuid = container.data.uuid;\n                console.log('KNOWN USER'+uuid);\n                if(uuid) {\n                    loggedIn = true;\n                    login_el.style.display = \"none\";\n                } else {\n                    updateLoginButton();\n                }\n            }\n         };\n    }\n    function start() {\n        snake.state = STATES.INITIALISING,\n        saveCurrentCfg();\n        modifyCfg();\n        setupPlayground();\n        getDimensions();\n        makeInitialSnake(snake_body);\n        markPoint(snake_body);\n        addKeyListener();\n        personaliseGame();\n    }\n    start();\n})();"]],"start1":0,"start2":0,"length1":0,"length2":31374}]],"length":31374,"saved":false}
{"contributors":[],"silentsave":false,"ts":1342330446287,"patch":[[{"diffs":[[1,"(function main() {\n    \"use strict\";\n    var LEFT_KEY_CODE = 37,\n        UP_KEY_CODE = 38,\n        RIGHT_KEY_CODE = 39,\n        DOWN_KEY_CODE = 40,\n        ESCAPE_KEY_CODE = 27,\n        SPACE_KEY_CODE = 32,//TO PAUSE THE GAME\n        RESTART_KEY_CODE = 82,//R KEY\n        SAVE_KEY_CODE = 113,//F2 KEY\n        NO_OF_INITIAL_BODY_PARTS = 3,\n        POSITIVE_90_ROTATION = \"rotate(90deg)\",\n        NEGATIVE_90_ROTATION = \"rotate(-90deg)\",\n        NEGATIVE_180_ROTATION = \"rotate(-180deg)\",\n        ZERO_ROTATION = \"\",\n        BODY_PART_SIZE, \n        SPEED = 60,\n        INCREASE_SIZE_BY = 1,\n        GULP_COUNTER_DIV_ID = 'snake_gulp_counter',\n        GULP_COUNTER_DIV_CLASS = 'snake_gulp_counter',\n        LAST_BODY_PART_SELECTOR = '#snake span:nth-last-child(1)',\n        SNAKE_FIGURE,\n        PLAYGROUND_CLASS = 'snake_playground',\n        PLAYGROUND_ID = 'snake_playground',\n        SNAKE_BODY_CLASS = 'snake',\n        SNAKE_BODY_ID = 'snake',\n        SNAKE_BODY_PART_CLASS = 'snake_body_part',\n        SNAKE_BODY_PART_ID = 'snake_body_part',\n        GAME_STATE_CLASS = 'snake_state',\n        GAME_STATE_ID = 'snake_state',\n        GAME_STATE_HTML = '<b>PAUSED</b>',\n        CRASH_OPTIONS_CLASS = 'crash_options',\n        CRASH_OPTIONS_ID = 'crash_options',\n        CRASH_OPTIONS_HTML = \"Press <b><i>'r'</i></b> to Restart or <b><i>'Esc'</i></b> to Exit\",\n        IFRAME_ID = \"snake_iframe\",\n        IFRAME_SRC = \"http://php-hariombalhara.rhcloud.com/personalise.html\",\n        STATES = {\n            RUNNING: 0, \n            PAUSED: 1,\n            ENDED: 2, //Game has ended .But things are still there.\n            INITIALISING: 3,\n            DESTROYED: 4 //Games has ended and complete playground has been destroyed\n            },\n        MSG_TYPE = { //It has a duplicate in personalise.js\n            UPLOAD_DATA: 'UPLOAD_DATA',\n            DATABASE_UPDATED: 'DATABASE_UPDATED',\n            UPDATE_PAGE: 'UPDATE_PAGE',\n            INITIATE_LOGIN: 'INITIATE_LOGIN',\n            INITIALIZE_HOST_PAGE: 'INITIALIZE_HOST_PAGE'\n        },\n        MODE = { //It has duplicate in personalise.js\n            SAVE_KILL: 0,\n            SAVE: 1,\n            SAVE_KILL_RESTART:2\n        },\n        playground_container,\n        body = document.body,\n        snake = window.snake = {},//Snake Namespace\n        point = snake.point = {},//Holds the position of the point.\n        original_cfg = snake.original_cfg = {},//It will hold the original style information for the page\n        key_queue = snake.key_queue = [],//Holds the keys to be processed\n        window_availWidth = -1,\n        window_availHeight = -1,\n        width = -1,\n        height = -1,\n        snake_playground = {},\n        snake_body = {},\n        state_of_game_el = {},\n        gulp_counter_el = {},\n        startover_max_counter = 0,\n        noSignIn = false,\n        crash_options,\n        iframe,\n        login_el,\n        loggedIn,\n        gameData = {},\n        bodyMap = gameData.bodyMap = [];\n    function getIntPartFromStr(str) {\n        return parseInt(str, 10);\n    }\n    function isDestroyed() {\n        if (snake.state === STATES.DESTROYED) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function isEnded() {\n        if (snake.state === STATES.ENDED) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function copy_style(el, save_obj) {\n        var style = el.style,\n            obj_style = {},\n            i;\n        if (!save_obj.style) {\n            obj_style = save_obj.style = {};\n        } else {\n            obj_style = save_obj.style;\n        }\n        for (i in style) { //TODO:Need to be more specific cause style can have methods too.This is a very genric approach,can cause problem in future\n            obj_style[i] = style[i];\n        }\n    }\n    function toggle(boolvar)\n    {\n        if (typeof boolvar !== 'boolean') {\n            throw new Error('boolvar is not a bool');\n        }\n        if (boolvar === true)\n        {\n            boolvar = false;\n        } else {\n            boolvar = true;\n        }\n        return boolvar;\n    }\n    //Save the current style info in case something wrong happens or fore restoration\n    function saveCurrentCfg() {\n        var b = original_cfg.body = {};\n        b.style = {};\n        b.style.overflow = body.style.overflow;\n        b.style.margin = body.style.margin;\n        original_cfg.document={title:document.title};\n        b.onbeforeunload = body.onbeforeunload; //TODO:Test it by attaching an onbeforeunload function to body on original site.\n        //copy_style(body, snake.original_cfg.body);\n    }\n    function actonbeforeunload() {\n      return 'Unsaved Changes';//Not shown\n    }\n    function modifyCfg() {\n        body.style.overflow = \"hidden\";\n        body.style.margin = \"0\";\n        body.onbeforeunload = actonbeforeunload;\n    }    \n    function moveStateTo(state) {\n        if (state === STATES.PAUSED) {\n            snake.state = state;\n            state_of_game_el.innerHTML = \"PAUSED\";\n            clearInterval(snake.interval);\n        } else if (state === STATES.ENDED) {\n            snake.state = state;\n            state_of_game_el.innerHTML = \"ENDED\";\n            clearInterval(snake.interval);\n        } else if (state == STATES.RUNNING) {\n            state_of_game_el.innerHTML = \"\";\n            snake.interval = setInterval(function() {simulateSnake(snake_body);}, SPEED);\n        }\n    }\n    function getDimensions() {\n        var common;\n        /*window_availWidth = snake_playground.offsetWidth;\n        window_availHeight = snake_playground.offsetHeight;\n        if(window_availHeight > window_availWidth) {\n            common = window_availHeight = window_availWidth;\n        } else {\n            common = window_availWidth = window_availHeight;\n        }*/\n        common = PLAYGROUND_DIMENSION;\n        BODY_PART_SIZE = Math.ceil(0.04 * common) ;\n        SNAKE_FIGURE = '<svg xmlns = \"http://www.w3.org/2000/svg\" version=\"1.1\"><rect class=\"snake_figure\" id=\"snake_figure\" width=\"' + BODY_PART_SIZE + '\" height=\"' + BODY_PART_SIZE + '\"/></svg>',\n        width = height = snake.width = snake.height = Math.floor(common-(common%BODY_PART_SIZE));\n    }\n    \n    function getDimensions_orig() {\n        window_availWidth = snake_playground.offsetWidth;\n        window_availHeight = snake_playground.offsetHeight;\n        width = snake.width = Math.floor(window_availWidth-(window_availWidth%BODY_PART_SIZE));\n        height = snake.height = Math.floor(window_availHeight-(window_availHeight%BODY_PART_SIZE));\n    }\n    function appendChildWithInformation(child) {\n        var el = createSnakeElement(child);\n        this.appendChild(el);\n        return el;\n    }\n    function createSnakeElement(props) {\n        var el = document.createElement(props.tagName),\n            props_style=props.style;\n        if (props.className) {\n            el.setAttribute('class', props.className);\n        }\n        if (props.id) {\n            el.setAttribute('id', props.id);\n        }\n        if (props.innerHTML) {\n            el.innerHTML = props.innerHTML;\n        }\n        if ((typeof props_style) !== \"undefined\") { //TODO:make it a generic style copier.\n            if ((typeof props_style.left) !== \"undefined\") {\n                el.style.left = props.style.left;\n            }\n            if ((typeof props_style.top) !== \"undefined\") {\n                el.style.top = props.style.top;\n            }\n            if ((typeof props_style.height) !== \"undefined\") {\n                el.style.height = props.style.height;\n            }\n            if ((typeof props_style.width) !== \"undefined\") {\n                el.style.width = props.style.width;\n            }\n        }\n        el.appendChildWithInformation = appendChildWithInformation;\n        return el;\n    }\n    function insertFrame() {\n        iframe = document.createElement('iframe');\n        iframe.id = IFRAME_ID;\n        iframe.src = IFRAME_SRC;\n        snake_playground.appendChild(iframe);\n    }\n\n    function init_persona_login(e) {\n        e.preventDefault();\n        var container = {\n            msgType:MSG_TYPE.INITIATE_LOGIN\n        };\n       postToHostingSite(container);\n    }\n    function continueAsGuest() {\n        login_el.style.display = \"none\";\n        noSignIn = true;\n    }\n    function updateLoginButton() {\n        var login_anchor=document.createElement('a');\n        var nologin_anchor=document.createElement('a');\n        login_anchor.onclick = init_persona_login;\n        login_anchor.href = \"javascript:void(null)\";\n        nologin_anchor.href = \"javascript:void(null)\";\n        nologin_anchor.innerHTML = \"OR &nbsp;&nbsp;GuestIn\";\n        nologin_anchor.onclick = continueAsGuest;\n        login_el.setAttribute('class','login_snake_game');\n        login_el.appendChild(login_anchor);\n        login_el.appendChild(nologin_anchor);\n    }\n    function insertLoginButton() {\n        login_el=document.createElement('div');\n        login_el.id = \"login_snake_game\";\n        login_el.setAttribute('class',\"login_snake_game\");\n        login_el.setAttribute('class',login_el.getAttribute('class')+\" waiting\");\n        snake_playground.appendChild(login_el);\n    }\n    function setupPlayground() {\n        playground_container = createSnakeElement({\n            tagName: 'div',\n            className: 'playground_container',\n            style: {\n                height: \"100%\",\n                width: \"100%\"\n            }\n        })\n        snake_playground = playground_container.appendChildWithInformation.call(playground_container,{\n            tagName: 'div',\n            className: PLAYGROUND_CLASS,\n            id: PLAYGROUND_ID,\n            style: {\n            height: PLAYGROUND_DIMENSION,\n            width: PLAYGROUND_DIMENSION\n        }\n    });//Its the root element for the snake game\n        snake_body = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: SNAKE_BODY_CLASS,\n            id: SNAKE_BODY_ID,\n            style: {\n            }\n        });\n        gulp_counter_el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: GULP_COUNTER_DIV_CLASS,\n            id: GULP_COUNTER_DIV_ID,\n            innerHTML: '0'\n        });\n        state_of_game_el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: GAME_STATE_CLASS,\n            id: GAME_STATE_ID,\n            innerHTML: GAME_STATE_HTML\n        });\n        crash_options = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: CRASH_OPTIONS_CLASS,\n            id: CRASH_OPTIONS_ID,\n            innerHTML: CRASH_OPTIONS_HTML\n        });\n        \n        body.appendChild(playground_container);\n        insertLoginButton();\n        insertFrame();\n        createPoint();\n    }\n    function gulp(el, consume) {\n        var i;\n        if((typeof gulp.id) === \"undefined\") {\n            gulp.id=0;\n        }\n        if((typeof gulp.count) === \"undefined\") {\n            gulp.count=0;\n        }\n        if(consume === true) {\n            for (i = 0; i < INCREASE_SIZE_BY; i++) {\n                gulp.id+=1;\n                var offsetx=0;\n                var offsety=0;\n                var firstChild = el.childNodes[0];\n                var firstChild_style = firstChild.style;\n                var left = getIntPartFromStr(firstChild_style.left);\n                var top = getIntPartFromStr(firstChild_style.top);\n                var rotation = firstChild.rotation;\n                //The insertion philosophy is opposite to usual\n                if(rotation === NEGATIVE_180_ROTATION) {\n                    offsetx = BODY_PART_SIZE;\n                } else if(rotation === ZERO_ROTATION) {\n                    offsetx=-BODY_PART_SIZE;\n                } else if(rotation === POSITIVE_90_ROTATION) {\n                    offsety=-BODY_PART_SIZE;\n                } else if(rotation === NEGATIVE_90_ROTATION) {\n                    offsety = BODY_PART_SIZE;\n                }\n                if((offsetx === 0) && (offsety === 0)) {\n                    console.log(\"RAISE EXCEPTION HERE\");\n                }\n                var span = createSnakeElement({\n                    tagName: 'span',\n                    className: SNAKE_BODY_PART_CLASS,\n                    id: SNAKE_BODY_PART_ID+gulp.id,\n                    innerHTML: SNAKE_FIGURE,\n                    style: {\n                        left:left+offsetx+\"px\",\n                        top:top+offsety+\"px\"\n                    }\n                });\n                span.rotation = rotation;\n                el.insertBefore(span, el.childNodes[0]);\n            }\n            gulp.count+=1;\n            gulp_counter_el.innerHTML = gulp.count;\n        } else {\n            gulp.id+=1;\n            el.appendChildWithInformation.call(el, {\n                tagName:'span',\n                className:SNAKE_BODY_PART_CLASS,\n                id:SNAKE_BODY_PART_ID+gulp.id,\n                innerHTML:SNAKE_FIGURE,\n                style:{\n                    left:0,\n                    top:0\n                }\n            });\n        }\n    }\n    function getInitialSnake(el) {\n        var i,\n            node,\n            obj;\n        window.snmap = gameData;\n        bodyMap = gameData.bodyMap; //Its Important\n        console.log(bodyMap.length);\n        for (i = 0; i < bodyMap.length; i++) {\n            gulp(el);\n            obj = bodyMap[i];\n            node = el.childNodes[i];\n            node.style.left = (obj.left)*width + \"px\";\n            node.style.top = (obj.top)*height + \"px\";\n            node.rotation = obj.rotation;\n        }\n        gulp_counter_el.innerHTML = gameData.score;\n        snake.paused = true;\n    }\n    function makeInitialSnake(el) {\n        var i;\n        for (i = 0; i < NO_OF_INITIAL_BODY_PARTS; i++) {\n            gulp(el);\n            if(i >= 1 && (i <  NO_OF_INITIAL_BODY_PARTS)) {\n                el.childNodes[i].style.left=(getIntPartFromStr(el.childNodes[i].style.left)+(i*BODY_PART_SIZE))+\"px\";\n            }\n        }\n        snake.paused = true;\n    }\n    function restoreCfg() {\n        var b = original_cfg.body;\n        body.style.overflow = b.style.overflow;\n        body.style.margin = b.style.margin;\n        document.title = original_cfg.document.title;\n        body.onbeforeunload = b.onbeforeunload;\n    }\n    function getInitialPoint() {\n        point.el.style.display = \"block\";\n        point.el.style.left = (gameData.point.left)*width + \"px\";\n        point.el.style.top = (gameData.point.top)*height + \"px\";\n    }\n    function createPoint() {\n        point.el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName:'div',\n            className:'snake_point',\n            id:'snake_point',\n            innerHTML:SNAKE_FIGURE,\n            style:{display:'none'}//don' work right now\n        });\n        point.el.style.display = \"none\";\n    }\n    function markPoint(el) { //TODO:Why create and destroy this element again and again.Just change its position.\n        var x = -1,\n            y = -1,\n            count = 0,\n            len = el.childNodes.length;\n            if(point.el.style.display !== \"block\")\n            point.el.style.display = \"block\";\n        while(true) {\n            var startover = false,\n                randx = Math.random(),\n                randy = Math.random(),\n                i;\n            x = (randx)*(getIntPartFromStr(width)-BODY_PART_SIZE);\n            y = (randy)*(getIntPartFromStr(height)-BODY_PART_SIZE);\n            x = x-(x%BODY_PART_SIZE);\n            y = y-(y%BODY_PART_SIZE);\n            for(i = 0; i < len-1; i++) {\n                var child = el.childNodes[i],\n                    child_style = child.style,\n                    top = child_style.top,\n                    left = child_style.left;\n                if((top === (y + \"px\")) && (left === (x + \"px\"))) {\n                    startover = true;\n                    if(startover_max_counter < count) {\n                        startover_max_counter = count;\n                        console.log(\"Startovercount highest value=\", startover_max_counter);\n                    }\n                    break;\n                }\n            }\n            if(!startover) {\n                break;\n            } else {\n                count++;\n            }\n        }\n        point.el.style.left = x+\"px\";\n        point.el.style.top = y+\"px\";\n    }\n    function append(keyCode) {\n        //FOR NOW ONLY THE LAST ELEMENT of QUEUE IS CONSIDERED\n        if(key_queue.length === 1) {\n            key_queue.shift();\n        }\n        key_queue.push(keyCode);\n    }\n    function addKeyListener() {\n        document.addEventListener(\"keydown\", keyEventListener, true);\n    }\n    function removeKeyListener() {\n        document.removeEventListener(\"keydown\", keyEventListener, true);\n    }\n    function freeze() {\n        clearInterval(snake.interval);\n        removeKeyListener();\n    }\n    function killGame() {\n        var script = document.getElementById('snake_script');\n        freeze();\n        try {\n            if(playground_container) {\n                body.removeChild(playground_container);\n            }\n        }\n        catch(e) {\n            console.log('Exception:', \"ParentNode=\"+snake_playground.parentNode, \"Node=\"+snake_playground);\n        }\n        restoreCfg();\n        if(script)\n        document.getElementsByTagName('head')[0].removeChild(script);\n    }\n    function restartGame() {\n        saveGame(MODE.SAVE_KILL_RESTART);\n    }\n    function crashSnake() {\n        if(isDestroyed() || (snake.state === STATES.ENDED)) {\n            console.log('Crash Snake-STATE:',snake.state);\n            return;\n        }\n        crash_options.style.display = \"block\";\n        moveStateTo(STATES.ENDED);\n    }\n    function checkUpCrash(last_style) {\n        if((getIntPartFromStr(last_style.top)) < 0) {\n            crashSnake();\n        }\n    }\n    function checkLeftCrash(last_style) {\n        if((getIntPartFromStr(last_style.left)) < 0) {\n            crashSnake();\n        }\n    }\n    function checkRightCrash(last_style, offset) {\n        if((getIntPartFromStr(last_style.left)+offset) > width) {\n            crashSnake();\n        }\n    }\n    function checkDownCrash(last_style, offset) {\n        if((getIntPartFromStr(last_style.top)+offset) > height) {\n            crashSnake();\n        }\n    }\n    function processGeneral(element, distance, leave_last) {\n        //TODO: make a copy of node list as traversing it is costly.\n        var len = element.childNodes.length,\n            up_to = len,\n            i;\n        if(leave_last) {\n            up_to = len-1;\n        }\n        for(i = 0; i < up_to; i++) {\n            var child = element.childNodes[i],\n                child_style = child.style,\n                rotation,\n                rotation_flag = false,\n                lookahead_rotation_flag,\n                left_coordinate,\n                top_coordinate;\n            child.rotation=((typeof child.rotation) === \"undefined\")?ZERO_ROTATION:child.rotation;\n            rotation = child.rotation;            \n            if(child.rotation === POSITIVE_90_ROTATION || child.rotation === NEGATIVE_90_ROTATION) {\n                rotation_flag = true;\n            }\n            lookahead_rotation_flag=-1;\n            left_coordinate = getIntPartFromStr(child_style.left);\n            top_coordinate = getIntPartFromStr(child_style.top);\n            if(i+1 < len) {\n                if(element.childNodes[i+1].rotation === POSITIVE_90_ROTATION || element.childNodes[i+1].rotation === NEGATIVE_90_ROTATION) {\n                    lookahead_rotation_flag = true;\n                }\n                if(element.childNodes[i+1].rotation === ZERO_ROTATION || element.childNodes[i+1].rotation === NEGATIVE_180_ROTATION) {\n                    lookahead_rotation_flag = false;\n                }\n            }\n            if(((typeof rotation_flag) === \"undefined\") || (rotation_flag === false)) {\n                child.isRotated = false;\n                if(((typeof lookahead_rotation_flag) !== \"undefined\") && (lookahead_rotation_flag === true)) {\n                    child.isRotated = true;\n                    child.rotation = element.childNodes[i+1].rotation;\n                    //Simulate rotation\n                    if(child.rotation === NEGATIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate-(distance)) + \"px\";\n                    }\n                    if(child.rotation === POSITIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate+(distance)) + \"px\";\n                    }\n                } else {\n                    if(rotation === ZERO_ROTATION) {\n                        child_style.left = (left_coordinate+(distance)) + \"px\";\n                    } else if(rotation === NEGATIVE_180_ROTATION) {\n                        child_style.left = (left_coordinate-(distance)) + \"px\";\n                    }\n                }\n            }\n            else {//rotation flag is true\n                if(((typeof lookahead_rotation_flag) === \"undefined\") || (lookahead_rotation_flag === false)) {\n                    child.isRotated = false;\n                    child.rotation = element.childNodes[i+1].rotation;\n                    //Simulate rotation\n                    if(child.rotation === ZERO_ROTATION) {\n                        child_style.left = (left_coordinate + (distance)) + \"px\";\n                    }\n                    if(child.rotation === NEGATIVE_180_ROTATION) {\n                        child_style.left = (left_coordinate-(distance))+\"px\";\n                    }\n                }\n                else\n                {\n                    if(rotation === NEGATIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate-(distance))+'px';\n                    }\n                    else if(rotation === POSITIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate+(distance))+'px';\n                    }\n                }\n            }\n        }\n    }\n    function checkOverlap(el) {\n        //TODO:copy childnodes to an array cause domenodes processing is costly\n        var last = body.querySelector(LAST_BODY_PART_SELECTOR),\n            last_style = last.style,\n            last_style_top = last_style.top,\n            last_style_left = last_style.left,\n            len = el.childNodes.length,\n            i;\n        for(i = 0; i < len-1; i++) {\n            var child = el.childNodes[i],\n                child_style = child.style,\n                top = child_style.top,\n                left = child_style.left;\n            if((top === last_style_top) && (left === last_style_left)) {\n                crashSnake();\n            }\n        }\n    }\n    function tryGulp(el) {\n        var last = body.querySelector(LAST_BODY_PART_SELECTOR);\n        var last_style = last.style;\n        var last_style_top = last_style.top;\n        var last_style_left = last_style.left;\n        if(((point.el.style.left) === last_style_left) && ((point.el.style.top) === last_style_top)) {\n           // snake_playground.removeChild(point.el);\n            gulp(el, true);\n            markPoint(el);\n        }\n    }\n    function processDownKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var top_coordinate = getIntPartFromStr(child_style.top);\n        var leave_last = false;\n        if((rotation === ZERO_ROTATION) || (rotation === NEGATIVE_180_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.top = (top_coordinate + (distance)) + \"px\";\n            element.childNodes[key].rotation = POSITIVE_90_ROTATION;\n        }\n    }\n    function processUpKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var top_coordinate = getIntPartFromStr(child_style.top);\n        var leave_last = false;\n        if((rotation === ZERO_ROTATION) || (rotation === NEGATIVE_180_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.top = (top_coordinate - (distance)) + \"px\";\n            element.childNodes[key].rotation = NEGATIVE_90_ROTATION;\n        }\n    }\n    function processRightKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var left_coordinate = getIntPartFromStr(child_style.left);\n        var leave_last = false;\n        if((rotation === POSITIVE_90_ROTATION) || (rotation === NEGATIVE_90_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.left = (left_coordinate + (distance)) + \"px\";\n            element.childNodes[key].rotation = ZERO_ROTATION;\n        }\n    }\n    function processLeftKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var left_coordinate = getIntPartFromStr(child_style.left);\n        var leave_last = false;\n        if((rotation === POSITIVE_90_ROTATION) || (rotation === NEGATIVE_90_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.left = (left_coordinate-(distance))+\"px\";\n            element.childNodes[key].rotation = NEGATIVE_180_ROTATION;\n        }\n    }\n    function processKeyEvent(el, keyCode) {\n        var no_of_child_nodes = el.childNodes.length;\n        var rotation = {};\n        rotation.value = el.childNodes[(no_of_child_nodes-1)].rotation;\n        el.childNodes[no_of_child_nodes-1].rotation = rotation.value = (typeof rotation.value === \"undefined\")?ZERO_ROTATION: rotation.value;\n        rotation.isNeg90 = (rotation.value === NEGATIVE_90_ROTATION );\n        rotation.isPos90 = (rotation.value === POSITIVE_90_ROTATION );\n        rotation.isNeg180=(rotation.value === NEGATIVE_180_ROTATION );\n        rotation.isZero = (rotation.value === ZERO_ROTATION );\n        var move_distance = BODY_PART_SIZE;\n        var last = document.body.querySelector(LAST_BODY_PART_SELECTOR);\n        var last_style = last.style;\n        var offset = BODY_PART_SIZE;\n        var isItTheExpectedKey = true;\n        switch(keyCode) {\n            case LEFT_KEY_CODE:\n                if(rotation.isNeg90 || rotation.isPos90 || rotation.isNeg180) {\n                    processLeftKey(el, move_distance);\n                    checkLeftCrash(last_style);\n                }\n                break;\n            case UP_KEY_CODE:\n                if(rotation.isNeg90 ||rotation.isZero || rotation.isNeg180) {\n                    processUpKey(el, move_distance);\n                    checkUpCrash(last_style);\n                }\n                break;\n            case RIGHT_KEY_CODE:\n                if(rotation.isPos90 || rotation.isZero || rotation.isNeg90) {\n                    processRightKey(el, move_distance);\n                    checkRightCrash(last_style, offset);\n                }\n                break;\n            case DOWN_KEY_CODE:\n                if(rotation.isPos90 || rotation.isZero || rotation.isNeg180) {\n                    processDownKey(el, move_distance);\n                    checkDownCrash(last_style, offset);\n                }\n                break;\n            default:\n                isItTheExpectedKey = false;\n                alert('Unexpected key');\n        }\n        if(isItTheExpectedKey) {\n            tryGulp(el);\n        }\n    }\n    function simulateSnake(el) {\n        var queue = key_queue;\n        var len = queue.length;\n        getDimensions(); //Get updated dimensions alwasy\n        if(len === 0) {\n            processGeneral(el, BODY_PART_SIZE);\n            //Not pressing any key means snake is moving in direction of last body_part\n            var last = body.querySelector(LAST_BODY_PART_SELECTOR);\n            var rotation = last.rotation;\n            var last_style = last.style;\n            // console.log(\"STYLE\", last_style)\n            var offset = BODY_PART_SIZE;//Need to adjust it\n            if(rotation === NEGATIVE_180_ROTATION) {\n                checkLeftCrash(last_style);\n            }\n            else if(rotation === ZERO_ROTATION) {\n                checkRightCrash(last_style, offset);\n            }\n            else if(rotation === POSITIVE_90_ROTATION) {\n                checkDownCrash(last_style, offset);\n            }\n            else if(rotation === NEGATIVE_90_ROTATION) {\n                checkUpCrash(last_style);\n            }\n            if(isDestroyed()) {\n                return;\n            }\n            checkOverlap(el);\n            tryGulp(el);\n        }\n        else {\n            processKeyEvent(el, queue.pop());\n        }\n    }\n\n    function postToHostingSite(container) {\n        //TODO:Put Restriction here for target ORigin\n        console.log('POSTING MESSAGE to Game Host'+JSON.stringify(container));\n        iframe.contentWindow.postMessage(container,'*');\n    }\n    function saveGame(mode) {\n        var container = {\n            msgType: MSG_TYPE.UPLOAD_DATA,\n            score: gulp_counter_el.innerHTML,\n            mode:mode\n        };\n        if(mode === MODE.SAVE) {\n            var childNodes = snake_body.childNodes,\n                len = childNodes.length,\n                node,i,xy = {},\n                p_xy = {};\n                p_xy.left = (getIntPartFromStr(point.el.style.left))/width;\n                p_xy.top = (getIntPartFromStr(point.el.style.top))/height;\n            for(i = 0; i < len; i++) {\n                xy = {};\n                node = childNodes[i];\n                xy.left = (getIntPartFromStr(node.style.left))/width;\n                xy.top = (getIntPartFromStr(node.style.top))/height;\n                xy.rotation = node.rotation;\n                bodyMap[i] = xy;\n            }\n            gameData.point = p_xy;\n            gameData.score = gulp_counter_el.innerHTML;\n            container.gameData = JSON.stringify(gameData);\n            console.log('Uploading FULL '+container.gameData);\n        } else {\n            playground_container.style.display = \"none\";//Set Display to none to make it look like the game is killed instantly.\n        }\n        postToHostingSite(container);\n    }\n    function keyEventListener(e) {\n        if((noSignIn || loggedIn)&&(e.keyCode === LEFT_KEY_CODE ||e.keyCode === DOWN_KEY_CODE ||e.keyCode === UP_KEY_CODE ||e.keyCode === RIGHT_KEY_CODE )) {\n            e.preventDefault();\n            e.stopPropagation();\n            if(!isDestroyed() && !isEnded()) {\n                append(e.keyCode);\n            }\n        } else {\n            if(e.keyCode === ESCAPE_KEY_CODE) {\n                if(isDestroyed()) {\n                    return;\n                }\n                e.preventDefault();\n                e.stopPropagation();\n                saveGame(MODE.SAVE_KILL);\n                //killGame();Game will be killed when a message is received that score is updated to database\n            } else if((noSignIn || loggedIn)&&(e.keyCode === SPACE_KEY_CODE)) {\n                e.preventDefault();\n                e.stopPropagation();\n                if(isDestroyed() || isEnded()) {\n                    return;\n                }\n                if(snake.paused === true) {\n                    moveStateTo(STATES.RUNNING);\n                } else {\n                    moveStateTo(STATES.PAUSED);\n                }\n                snake.paused = toggle(snake.paused);\n            } else if((noSignIn || loggedIn)&&(e.keyCode === RESTART_KEY_CODE)) {\n                e.preventDefault();\n                e.stopPropagation();\n                restartGame();\n            } else if((noSignIn || loggedIn)&&(e.keyCode === SAVE_KEY_CODE)) {\n                e.preventDefault();\n                e.stopPropagation();\n                saveGame(MODE.SAVE);\n            }\n        }\n    }\n    function personaliseGame() {\n         window.onmessage = function(e) {\n            var container = e.data,\n                data;\n            //TODO: Put restrictions somehow on which origin is accepted\n            console.log(\"ONMESSAGE EVENT received on Parent\");\n            if(container.msgType === MSG_TYPE.DATABASE_UPDATED) {\n                console.log('Received DATABASE_UDPATED.Killing Now');\n                if(container.mode === MODE.SAVE_KILL) {\n                    killGame();\n                } else if(container.mode === MODE.SAVE_KILL_RESTART) {\n                    killGame();\n                    main();\n                }\n            }\n            else if(container.msgType === MSG_TYPE.UPDATE_PAGE) {\n                data = container.data;\n                if(data.highestScore !== '-1') {\n                    gulp_counter_el.innerHTML = data.highestScore;\n                }\n                login_el.style.display = \"none\";\n                document.title = \"Hi \"+data.email+\"(\"+data.name+\")\";\n                if(data.uuid) {\n                    loggedIn = true;\n                }\n                console.log('KNOWN USER1'+data.uuid);\n                if(data.gameData) {\n                    gameData = eval(\"(\"+data.gameData+\")\");\n                    console.log(JSON.stringify(gameData));\n                    if(gameData) {\n                        getInitialSnake(snake_body);\n                        getInitialPoint(snake_body);\n                    }\n                    else {\n                        makeInitialSnake(snake_body);\n                        markPoint(snake_body);\n                    }\n                } else {\n                    makeInitialSnake(snake_body);\n                    markPoint(snake_body);\n                }\n            } else if(container.msgType === MSG_TYPE.INITIALIZE_HOST_PAGE) {\n                var uuid = container.data.uuid;\n                console.log('KNOWN USER'+uuid);\n                if(uuid) {\n                    loggedIn = true;\n                    login_el.style.display = \"none\";\n                } else {\n                    updateLoginButton();\n                }\n            }\n         };\n    }\n    function start() {\n        snake.state = STATES.INITIALISING,\n        saveCurrentCfg();\n        modifyCfg();\n        getDimensions();\n        setupPlayground();\n        //makeInitialSnake(snake_body);\n        //markPoint(snake_body);\n        addKeyListener();\n        personaliseGame();\n    }\n    start();\n})();"]],"start1":0,"start2":0,"length1":0,"length2":34834}]],"length":34834,"saved":false}
{"contributors":[],"silentsave":false,"ts":1342330480716,"patch":[[{"diffs":[[0,"RT_SIZE,"],[-1," "],[1,"\n        PLAYGROUND_DIMENSION = 500,"],[0,"\n       "]],"start1":530,"start2":530,"length1":17,"length2":52}]],"length":34869,"saved":false}
{"contributors":[],"silentsave":false,"ts":1342331928158,"patch":[[{"diffs":[[0,"on getDimensions"],[1,"_1"],[0,"() {\n"],[-1,""],[0,"        var comm"]],"start1":5487,"start2":5487,"length1":37,"length2":39},{"diffs":[[0,"    "],[-1,"BODY_PART_SIZE = Math.ceil(0.04 * common) ;\n        SNAKE_FIGURE = '<svg xmlns = \"http://www.w3.org/2000/svg\" version=\"1.1\"><rect class=\"snake_figure\" id=\"snake_figure\" width=\"' + BODY_PART_SIZE + '\" height=\"' + BODY_PART_SIZE + '\"/></svg>',"],[0,"\n   "]],"start1":5897,"start2":5897,"length1":249,"length2":8},{"diffs":[[0,"ions"],[-1,"_orig"],[0,"() {"]],"start1":6033,"start2":6033,"length1":13,"length2":8},{"diffs":[[0,"d.offsetHeight;\n"],[1,"        BODY_PART_SIZE = Math.ceil(0.04 * common) ;\n        SNAKE_FIGURE = '<svg xmlns = \"http://www.w3.org/2000/svg\" version=\"1.1\"><rect class=\"snake_figure\" id=\"snake_figure\" width=\"' + BODY_PART_SIZE + '\" height=\"' + BODY_PART_SIZE + '\"/></svg>',\n"],[0,"        width = "]],"start1":6144,"start2":6144,"length1":32,"length2":282},{"diffs":[[0,"ke(snake_body);\n"],[1,""],[0,"        //markPo"]],"start1":34749,"start2":34749,"length1":32,"length2":32},{"diffs":[[0,")();"],[-1,"(function main() {\n    \"use strict\";\n    var LEFT_KEY_CODE = 37,\n        UP_KEY_CODE = 38,\n        RIGHT_KEY_CODE = 39,\n        DOWN_KEY_CODE = 40,\n        ESCAPE_KEY_CODE = 27,\n        SPACE_KEY_CODE = 32,//TO PAUSE THE GAME\n        RESTART_KEY_CODE = 82,//R KEY\n        SAVE_KEY_CODE = 113,//F2 KEY\n        NO_OF_INITIAL_BODY_PARTS = 3,\n        POSITIVE_90_ROTATION = \"rotate(90deg)\",\n        NEGATIVE_90_ROTATION = \"rotate(-90deg)\",\n        NEGATIVE_180_ROTATION = \"rotate(-180deg)\",\n        ZERO_ROTATION = \"\",\n        BODY_PART_SIZE = 20, \n        SPEED = 60,\n        INCREASE_SIZE_BY = 1,\n        GULP_COUNTER_DIV_ID = 'snake_gulp_counter',\n        GULP_COUNTER_DIV_CLASS = 'snake_gulp_counter',\n        LAST_BODY_PART_SELECTOR = '#snake span:nth-last-child(1)',\n        SNAKE_FIGURE = '<svg xmlns = \"http://www.w3.org/2000/svg\" version=\"1.1\"><rect class=\"snake_figure\" id=\"snake_figure\" width=\"' + BODY_PART_SIZE + '\" height=\"' + BODY_PART_SIZE + '\"/></svg>',\n        PLAYGROUND_CLASS = 'snake_playground',\n        PLAYGROUND_ID = 'snake_playground',\n        SNAKE_BODY_CLASS = 'snake',\n        SNAKE_BODY_ID = 'snake',\n        SNAKE_BODY_PART_CLASS = 'snake_body_part',\n        SNAKE_BODY_PART_ID = 'snake_body_part',\n        GAME_STATE_CLASS = 'snake_state',\n        GAME_STATE_ID = 'snake_state',\n        GAME_STATE_HTML = '<b>PAUSED</b>',\n        CRASH_OPTIONS_CLASS = 'crash_options',\n        CRASH_OPTIONS_ID = 'crash_options',\n        CRASH_OPTIONS_HTML = \"Press <b><i>'r'</i></b> to Restart or <b><i>'Esc'</i></b> to Exit\",\n        IFRAME_ID = \"snake_iframe\",\n        IFRAME_SRC = \"http://php-hariombalhara.rhcloud.com/personalise.html\",\n        STATES = {\n            RUNNING: 0, \n            PAUSED: 1,\n            ENDED: 2, //Game has ended .But things are still there.\n            INITIALISING: 3,\n            DESTROYED: 4 //Games has ended and complete playground has been destroyed\n            },\n        MSG_TYPE = { //It has a duplicate in personalise.js\n            UPLOAD_DATA: 'UPLOAD_DATA', //Right Now its just the score\n            DATABASE_UPDATED: 'DATABASE_UPDATED',\n            UPDATE_PAGE: 'UPDATE_PAGE',\n            INITIATE_LOGIN: 'INITIATE_LOGIN',\n            INITIALIZE_HOST_PAGE: 'INITIALIZE_HOST_PAGE'\n        },\n        MODE = { //It has duplicate in personalise.js\n            SAVE_KILL: 0,\n            SAVE: 1,\n            SAVE_KILL_RESTART:2\n        },\n        body = document.body,\n        snake = window.snake = {},//Snake Namespace\n        point = snake.point = {},//Holds the position of the point.\n        original_cfg = snake.original_cfg = {},//It will hold the original style information for the page\n        key_queue = snake.key_queue = [],//Holds the keys to be processed\n        window_availWidth = -1,\n        window_availHeight = -1,\n        width = -1,\n        height = -1,\n        snake_playground = {},\n        snake_body = {},\n        state_of_game_el = {},\n        gulp_counter_el = {},\n        startover_max_counter = 0,\n        noSignIn = false,\n        crash_options,\n        iframe,\n        login_el,\n        loggedIn,\n        body_map = [];\n    function getIntPartFromStr(str) {\n        return parseInt(str, 10);\n    }\n    function isDestroyed() {\n        if (snake.state === STATES.DESTROYED) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function isEnded() {\n        if (snake.state === STATES.ENDED) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function copy_style(el, save_obj) {\n        var style = el.style,\n            obj_style = {},\n            i;\n        if (!save_obj.style) {\n            obj_style = save_obj.style = {};\n        } else {\n            obj_style = save_obj.style;\n        }\n        for (i in style) { //TODO:Need to be more specific cause style can have methods too.This is a very genric approach,can cause problem in future\n            obj_style[i] = style[i];\n        }\n    }\n    function toggle(boolvar)\n    {\n        if (typeof boolvar !== 'boolean') {\n            throw new Error('boolvar is not a bool');\n        }\n        if (boolvar === true)\n        {\n            boolvar = false;\n        } else {\n            boolvar = true;\n        }\n        return boolvar;\n    }\n    //Save the current style info in case something wrong happens or fore restoration\n    function saveCurrentCfg() {\n        var b = original_cfg.body = {};\n        b.style = {};\n        b.style.overflow = body.style.overflow;\n        b.style.margin = body.style.margin;\n        original_cfg.document={title:document.title};\n        b.onbeforeunload = body.onbeforeunload; //TODO:Test it by attaching an onbeforeunload function to body on original site.\n        //copy_style(body, snake.original_cfg.body);\n    }\n    function actonbeforeunload() {\n      return 'Unsaved Changes';//Not shown\n    }\n    function modifyCfg() {\n        body.style.overflow = \"hidden\";\n        body.style.margin = \"0\";\n        body.onbeforeunload = actonbeforeunload;\n    }    \n    function moveStateTo(state) {\n        if (state === STATES.PAUSED) {\n            snake.state = state;\n            state_of_game_el.innerHTML = \"PAUSED\";\n            clearInterval(snake.interval);\n        } else if (state === STATES.ENDED) {\n            snake.state = state;\n            state_of_game_el.innerHTML = \"ENDED\";\n            clearInterval(snake.interval);\n        } else if (state == STATES.RUNNING) {\n            state_of_game_el.innerHTML = \"\";\n            snake.interval = setInterval(function() {simulateSnake(snake_body);}, SPEED);\n        }\n    }\n    function getDimensions() {\n        window_availWidth = snake_playground.offsetWidth;\n        window_availHeight = snake_playground.offsetHeight;\n        width = snake.width = Math.floor(window_availWidth-(window_availWidth%BODY_PART_SIZE));\n        height = snake.height = Math.floor(window_availHeight-(window_availHeight%BODY_PART_SIZE));\n    }\n    function appendChildWithInformation(child) {\n        var el = createSnakeElement(child);\n        this.appendChild(el);\n        return el;\n    }\n    function createSnakeElement(props) {\n        var el = document.createElement(props.tagName),\n            props_style=props.style;\n        if (props.className) {\n            el.setAttribute('class', props.className);\n        }\n        if (props.id) {\n            el.setAttribute('id', props.id);\n        }\n        if (props.innerHTML) {\n            el.innerHTML = props.innerHTML;\n        }\n        if ((typeof props_style) !== \"undefined\") {\n            if ((typeof props_style.left) !== \"undefined\") {\n                el.style.left = props.style.left;\n            }\n            if ((typeof props_style.top) !== \"undefined\") {\n                el.style.top = props.style.top;\n            }\n            if ((typeof props_style.height) !== \"undefined\") {\n                el.style.height = props.style.height;\n            }\n            if ((typeof props_style.width) !== \"undefined\") {\n                el.style.width = props.style.width;\n            }\n        }\n        el.appendChildWithInformation = appendChildWithInformation;\n        return el;\n    }\n    function insertFrame() {\n        iframe = document.createElement('iframe');\n        iframe.id = IFRAME_ID;\n        iframe.src = IFRAME_SRC;\n        snake_playground.appendChild(iframe);\n    }\n\n    function init_persona_login(e) {\n        e.preventDefault();\n        var container = {\n            msgType:MSG_TYPE.INITIATE_LOGIN\n        };\n       postToHostingSite(container);\n    }\n    function continueAsGuest() {\n        login_el.style.display = \"none\";\n        noSignIn = true;\n    }\n    function updateLoginButton() {\n        var login_anchor=document.createElement('a');\n        var nologin_anchor=document.createElement('a');\n        login_anchor.onclick = init_persona_login;\n        login_anchor.href = \"javascript:void(null)\";\n        nologin_anchor.href = \"javascript:void(null)\";\n        nologin_anchor.innerHTML = \"OR &nbsp;&nbsp;GuestIn\";\n        nologin_anchor.onclick = continueAsGuest;\n        login_el.setAttribute('class','login_snake_game');\n        login_el.appendChild(login_anchor);\n        login_el.appendChild(nologin_anchor);\n    }\n    function insertLoginButton() {\n        login_el=document.createElement('div');\n        login_el.id = \"login_snake_game\";\n        login_el.setAttribute('class',\"login_snake_game\");\n        login_el.setAttribute('class',login_el.getAttribute('class')+\" waiting\");\n        snake_playground.appendChild(login_el);\n    }\n    function setupPlayground() {\n        snake_playground = createSnakeElement({\n            tagName: 'div',\n            className: PLAYGROUND_CLASS,\n            id: PLAYGROUND_ID,\n            style: {\n            height: \"100%\",\n            width: \"100%\"\n        }\n    });//Its the root element for the snake game\n        snake_body = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: SNAKE_BODY_CLASS,\n            id: SNAKE_BODY_ID,\n            style: {\n            }\n        });\n        gulp_counter_el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: GULP_COUNTER_DIV_CLASS,\n            id: GULP_COUNTER_DIV_ID,\n            innerHTML: '0'\n        });\n        state_of_game_el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: GAME_STATE_CLASS,\n            id: GAME_STATE_ID,\n            innerHTML: GAME_STATE_HTML\n        });\n        crash_options = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: CRASH_OPTIONS_CLASS,\n            id: CRASH_OPTIONS_ID,\n            innerHTML: CRASH_OPTIONS_HTML\n        });\n        //Finally append the snake playground to the body.\n        body.appendChild(snake_playground);\n        insertLoginButton();\n        insertFrame();\n        \n    }\n    function gulp(el, consume) {\n        var i;\n        if((typeof gulp.id) === \"undefined\") {\n            gulp.id=0;\n        }\n        if((typeof gulp.count) === \"undefined\") {\n            gulp.count=0;\n        }\n        if(consume === true) {\n            for (i = 0; i < INCREASE_SIZE_BY; i++) {\n                gulp.id+=1;\n                var offsetx=0;\n                var offsety=0;\n                var firstChild = el.childNodes[0];\n                var firstChild_style = firstChild.style;\n                var left = getIntPartFromStr(firstChild_style.left);\n                var top = getIntPartFromStr(firstChild_style.top);\n                var rotation = firstChild.rotation;\n                //The insertion philosophy is opposite to usual\n                if(rotation === NEGATIVE_180_ROTATION) {\n                    offsetx = BODY_PART_SIZE;\n                } else if(rotation === ZERO_ROTATION) {\n                    offsetx=-BODY_PART_SIZE;\n                } else if(rotation === POSITIVE_90_ROTATION) {\n                    offsety=-BODY_PART_SIZE;\n                } else if(rotation === NEGATIVE_90_ROTATION) {\n                    offsety = BODY_PART_SIZE;\n                }\n                if((offsetx === 0) && (offsety === 0)) {\n                    console.log(\"RAISE EXCEPTION HERE\");\n                }\n                var span = createSnakeElement({\n                    tagName: 'span',\n                    className: SNAKE_BODY_PART_CLASS,\n                    id: SNAKE_BODY_PART_ID+gulp.id,\n                    innerHTML: SNAKE_FIGURE,\n                    style: {\n                        left:left+offsetx+\"px\",\n                        top:top+offsety+\"px\"\n                    }\n                });\n                span.rotation = rotation;\n                el.insertBefore(span, el.childNodes[0]);\n            }\n            gulp.count+=1;\n            gulp_counter_el.innerHTML = gulp.count;\n        } else {\n            gulp.id+=1;\n            el.appendChildWithInformation.call(el, {\n                tagName:'span',\n                className:SNAKE_BODY_PART_CLASS,\n                id:SNAKE_BODY_PART_ID+gulp.id,\n                innerHTML:SNAKE_FIGURE,\n                style:{\n                    left:0,\n                    top:0\n                }\n            });\n        }\n    }\n    function makeInitialSnake(el) {\n        var i;\n        for (i = 0; i < NO_OF_INITIAL_BODY_PARTS; i++) {\n            gulp(el);\n            if(i >= 1 && (i <  NO_OF_INITIAL_BODY_PARTS)) {\n                el.childNodes[i].style.left=(getIntPartFromStr(el.childNodes[i].style.left)+(i*BODY_PART_SIZE))+\"px\";\n            }\n        }\n        snake.paused = true;\n    }\n    function restoreCfg() {\n        var b = original_cfg.body;\n        body.style.overflow = b.style.overflow;\n        body.style.margin = b.style.margin;\n        document.title = original_cfg.document.title;\n        body.onbeforeunload = b.onbeforeunload;\n    }\n    function markPoint(el) {\n        var x = -1,\n            y = -1,\n            count = 0,\n            len = el.childNodes.length;\n        while(true) {\n            var startover = false,\n                randx = Math.random(),\n                randy = Math.random(),\n                i;\n            x = (randx)*(getIntPartFromStr(width)-BODY_PART_SIZE);\n            y = (randy)*(getIntPartFromStr(height)-BODY_PART_SIZE);\n            x = x-(x%BODY_PART_SIZE);\n            y = y-(y%BODY_PART_SIZE);\n            for(i = 0; i < len-1; i++) {\n                var child = el.childNodes[i],\n                    child_style = child.style,\n                    top = child_style.top,\n                    left = child_style.left;\n                if((top === (y + \"px\")) && (left === (x + \"px\"))) {\n                    startover = true;\n                    if(startover_max_counter < count) {\n                        startover_max_counter = count;\n                        console.log(\"Startovercount highest value=\", startover_max_counter);\n                    }\n                    break;\n                }\n            }\n            if(!startover) {\n                break;\n            } else {\n                count++;\n            }\n        }\n        point.el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName:'div',\n            className:'snake_point',\n            id:'snake_point',\n            innerHTML:SNAKE_FIGURE,\n            style:{\n                left:x+\"px\",\n                top:y+\"px\"\n            }\n        });\n        //Store the position of the point in snake namespace for easy accessibilty\n        point.x = x;\n        point.y = y;\n    }\n    function append(keyCode) {\n        //FOR NOW ONLY THE LAST ELEMENT of QUEUE IS CONSIDERED\n        if(key_queue.length === 1) {\n            key_queue.shift();\n        }\n        key_queue.push(keyCode);\n    }\n    function addKeyListener() {\n        document.addEventListener(\"keydown\", keyEventListener, true);\n    }\n    function removeKeyListener() {\n        document.removeEventListener(\"keydown\", keyEventListener, true);\n    }\n    function freeze() {\n        clearInterval(snake.interval);\n        removeKeyListener();\n    }\n    function killGame() {\n        var script = document.getElementById('snake_script');\n        freeze();\n        try {\n            if(snake_playground) {\n                body.removeChild(snake_playground);\n            }\n        }\n        catch(e) {\n            console.log('Exception:', \"ParentNode=\"+snake_playground.parentNode, \"Node=\"+snake_playground);\n        }\n        restoreCfg();\n        if(script)\n        document.getElementsByTagName('head')[0].removeChild(script);\n    }\n    function restartGame() {\n        saveScore(MODE.SAVE_KILL_RESTART);\n    }\n    function crashSnake() {\n        if(isDestroyed() || (snake.state === STATES.ENDED)) {\n            console.log('Crash Snake-STATE:',snake.state);\n            return;\n        }\n        crash_options.style.display = \"block\";\n        moveStateTo(STATES.ENDED);\n    }\n    function checkUpCrash(last_style) {\n        if((getIntPartFromStr(last_style.top)) < 0) {\n            crashSnake();\n        }\n    }\n    function checkLeftCrash(last_style) {\n        if((getIntPartFromStr(last_style.left)) < 0) {\n            crashSnake();\n        }\n    }\n    function checkRightCrash(last_style, offset) {\n        if((getIntPartFromStr(last_style.left)+offset) > width) {\n            crashSnake();\n        }\n    }\n    function checkDownCrash(last_style, offset) {\n        if((getIntPartFromStr(last_style.top)+offset) > height) {\n            crashSnake();\n        }\n    }\n    function processGeneral(element, distance, leave_last) {\n        //TODO: make a copy of node list as traversing it is costly.\n        var len = element.childNodes.length,\n            up_to = len,\n            i;\n        if(leave_last) {\n            up_to = len-1;\n        }\n        for(i = 0; i < up_to; i++) {\n            var child = element.childNodes[i],\n                child_style = child.style,\n                rotation,\n                rotation_flag = false,\n                lookahead_rotation_flag,\n                left_coordinate,\n                top_coordinate;\n            child.rotation=((typeof child.rotation) === \"undefined\")?ZERO_ROTATION:child.rotation;\n            rotation = child.rotation;            \n            if(child.rotation === POSITIVE_90_ROTATION || child.rotation === NEGATIVE_90_ROTATION) {\n                rotation_flag = true;\n            }\n            lookahead_rotation_flag=-1;\n            left_coordinate = getIntPartFromStr(child_style.left);\n            top_coordinate = getIntPartFromStr(child_style.top);\n            if(i+1 < len) {\n                if(element.childNodes[i+1].rotation === POSITIVE_90_ROTATION || element.childNodes[i+1].rotation === NEGATIVE_90_ROTATION) {\n                    lookahead_rotation_flag = true;\n                }\n                if(element.childNodes[i+1].rotation === ZERO_ROTATION || element.childNodes[i+1].rotation === NEGATIVE_180_ROTATION) {\n                    lookahead_rotation_flag = false;\n                }\n            }\n            if(((typeof rotation_flag) === \"undefined\") || (rotation_flag === false)) {\n                child.isRotated = false;\n                if(((typeof lookahead_rotation_flag) !== \"undefined\") && (lookahead_rotation_flag === true)) {\n                    child.isRotated = true;\n                    child.rotation = element.childNodes[i+1].rotation;\n                    //Simulate rotation\n                    if(child.rotation === NEGATIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate-(distance)) + \"px\";\n                    }\n                    if(child.rotation === POSITIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate+(distance)) + \"px\";\n                    }\n                } else {\n                    if(rotation === ZERO_ROTATION) {\n                        child_style.left = (left_coordinate+(distance)) + \"px\";\n                    } else if(rotation === NEGATIVE_180_ROTATION) {\n                        child_style.left = (left_coordinate-(distance)) + \"px\";\n                    }\n                }\n            }\n            else {//rotation flag is true\n                if(((typeof lookahead_rotation_flag) === \"undefined\") || (lookahead_rotation_flag === false)) {\n                    child.isRotated = false;\n                    child.rotation = element.childNodes[i+1].rotation;\n                    //Simulate rotation\n                    if(child.rotation === ZERO_ROTATION) {\n                        child_style.left = (left_coordinate + (distance)) + \"px\";\n                    }\n                    if(child.rotation === NEGATIVE_180_ROTATION) {\n                        child_style.left = (left_coordinate-(distance))+\"px\";\n                    }\n                }\n                else\n                {\n                    if(rotation === NEGATIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate-(distance))+'px';\n                    }\n                    else if(rotation === POSITIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate+(distance))+'px';\n                    }\n                }\n            }\n        }\n    }\n    function checkOverlap(el) {\n        //TODO:copy childnodes to an array cause domenodes processing is costly\n        var last = body.querySelector(LAST_BODY_PART_SELECTOR),\n            last_style = last.style,\n            last_style_top = last_style.top,\n            last_style_left = last_style.left,\n            len = el.childNodes.length,\n            i;\n        for(i = 0; i < len-1; i++) {\n            var child = el.childNodes[i],\n                child_style = child.style,\n                top = child_style.top,\n                left = child_style.left;\n            if((top === last_style_top) && (left === last_style_left)) {\n                crashSnake();\n            }\n        }\n    }\n    function tryGulp(el) {\n        var last = body.querySelector(LAST_BODY_PART_SELECTOR);\n        var last_style = last.style;\n        var last_style_top = last_style.top;\n        var last_style_left = last_style.left;\n        if(((snake.point.x+\"px\") === last_style_left) && ((snake.point.y+\"px\") === last_style_top)) {\n            snake_playground.removeChild(point.el);\n            gulp(el, true);\n            markPoint(el);\n        }\n    }\n    function processDownKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var top_coordinate = getIntPartFromStr(child_style.top);\n        var leave_last = false;\n        if((rotation === ZERO_ROTATION) || (rotation === NEGATIVE_180_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.top = (top_coordinate + (distance)) + \"px\";\n            element.childNodes[key].rotation = POSITIVE_90_ROTATION;\n        }\n    }\n    function processUpKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var top_coordinate = getIntPartFromStr(child_style.top);\n        var leave_last = false;\n        if((rotation === ZERO_ROTATION) || (rotation === NEGATIVE_180_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.top = (top_coordinate - (distance)) + \"px\";\n            element.childNodes[key].rotation = NEGATIVE_90_ROTATION;\n        }\n    }\n    function processRightKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var left_coordinate = getIntPartFromStr(child_style.left);\n        var leave_last = false;\n        if((rotation === POSITIVE_90_ROTATION) || (rotation === NEGATIVE_90_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.left = (left_coordinate + (distance)) + \"px\";\n            element.childNodes[key].rotation = ZERO_ROTATION;\n        }\n    }\n    function processLeftKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var left_coordinate = getIntPartFromStr(child_style.left);\n        var leave_last = false;\n        if((rotation === POSITIVE_90_ROTATION) || (rotation === NEGATIVE_90_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.left = (left_coordinate-(distance))+\"px\";\n            element.childNodes[key].rotation = NEGATIVE_180_ROTATION;\n        }\n    }\n    function processKeyEvent(el, keyCode) {\n        var no_of_child_nodes = el.childNodes.length;\n        var rotation = {};\n        rotation.value = el.childNodes[(no_of_child_nodes-1)].rotation;\n        el.childNodes[no_of_child_nodes-1].rotation = rotation.value = (typeof rotation.value === \"undefined\")?ZERO_ROTATION: rotation.value;\n        rotation.isNeg90 = (rotation.value === NEGATIVE_90_ROTATION );\n        rotation.isPos90 = (rotation.value === POSITIVE_90_ROTATION );\n        rotation.isNeg180=(rotation.value === NEGATIVE_180_ROTATION );\n        rotation.isZero = (rotation.value === ZERO_ROTATION );\n        var move_distance = BODY_PART_SIZE;\n        var last = document.body.querySelector(LAST_BODY_PART_SELECTOR);\n        var last_style = last.style;\n        var offset = BODY_PART_SIZE;\n        var isItTheExpectedKey = true;\n        switch(keyCode) {\n            case LEFT_KEY_CODE:\n                if(rotation.isNeg90 || rotation.isPos90 || rotation.isNeg180) {\n                    processLeftKey(el, move_distance);\n                    checkLeftCrash(last_style);\n                }\n                break;\n            case UP_KEY_CODE:\n                if(rotation.isNeg90 ||rotation.isZero || rotation.isNeg180) {\n                    processUpKey(el, move_distance);\n                    checkUpCrash(last_style);\n                }\n                break;\n            case RIGHT_KEY_CODE:\n                if(rotation.isPos90 || rotation.isZero || rotation.isNeg90) {\n                    processRightKey(el, move_distance);\n                    checkRightCrash(last_style, offset);\n                }\n                break;\n            case DOWN_KEY_CODE:\n                if(rotation.isPos90 || rotation.isZero || rotation.isNeg180) {\n                    processDownKey(el, move_distance);\n                    checkDownCrash(last_style, offset);\n                }\n                break;\n            default:\n                isItTheExpectedKey = false;\n                alert('Unexpected key');\n        }\n        if(isItTheExpectedKey) {\n            tryGulp(el);\n        }\n    }\n    function simulateSnake(el) {\n        var queue = key_queue;\n        var len = queue.length;\n        getDimensions(); //Get updated dimensions alwasy\n        if(len === 0) {\n            processGeneral(el, BODY_PART_SIZE);\n            //Not pressing any key means snake is moving in direction of last body_part\n            var last = body.querySelector(LAST_BODY_PART_SELECTOR);\n            var rotation = last.rotation;\n            var last_style = last.style;\n            // console.log(\"STYLE\", last_style)\n            var offset = BODY_PART_SIZE;//Need to adjust it\n            if(rotation === NEGATIVE_180_ROTATION) {\n                checkLeftCrash(last_style);\n            }\n            else if(rotation === ZERO_ROTATION) {\n                checkRightCrash(last_style, offset);\n            }\n            else if(rotation === POSITIVE_90_ROTATION) {\n                checkDownCrash(last_style, offset);\n            }\n            else if(rotation === NEGATIVE_90_ROTATION) {\n                checkUpCrash(last_style);\n            }\n            if(isDestroyed()) {\n                return;\n            }\n            checkOverlap(el);\n            tryGulp(el);\n        }\n        else {\n            processKeyEvent(el, queue.pop());\n        }\n    }\n\n    function postToHostingSite(container) {\n        //TODO:Put Restriction here for target ORigin\n        console.log('POSTING MESSAGE to Game Host'+iframe);\n        iframe.contentWindow.postMessage(container,'*');\n    }\n    function saveScore(mode) {\n        var container = {\n            msgType: MSG_TYPE.UPLOAD_DATA,\n            score: gulp_counter_el.innerHTML,\n            mode:mode\n        };\n        if(mode != MODE.SAVE)\n        snake_playground.style.display = \"none\";//Set Display to none to make it look like the game is killed instantly.\n        postToHostingSite(container);\n    }\n    function keyEventListener(e) {\n        if((noSignIn || loggedIn)&&(e.keyCode === LEFT_KEY_CODE ||e.keyCode === DOWN_KEY_CODE ||e.keyCode === UP_KEY_CODE ||e.keyCode === RIGHT_KEY_CODE )) {\n            e.preventDefault();\n            e.stopPropagation();\n            if(!isDestroyed() && !isEnded()) {\n                append(e.keyCode);\n            }\n        } else {\n            if(e.keyCode === ESCAPE_KEY_CODE) {\n                if(isDestroyed()) {\n                    return;\n                }\n                e.preventDefault();\n                e.stopPropagation();\n                saveScore(MODE.SAVE_KILL);\n                //killGame();Game will be killed when a message is received that score is updated to database\n            } else if((noSignIn || loggedIn)&&(e.keyCode === SPACE_KEY_CODE)) {\n                e.preventDefault();\n                e.stopPropagation();\n                if(isDestroyed() || isEnded()) {\n                    return;\n                }\n                if(snake.paused === true) {\n                    moveStateTo(STATES.RUNNING);\n                } else {\n                    moveStateTo(STATES.PAUSED);\n                }\n                snake.paused = toggle(snake.paused);\n            } else if((noSignIn || loggedIn)&&(e.keyCode === RESTART_KEY_CODE)) {\n                e.preventDefault();\n                e.stopPropagation();\n                restartGame();\n            } else if((noSignIn || loggedIn)&&(e.keyCode === SAVE_KEY_CODE)) {\n                e.preventDefault();\n                e.stopPropagation();\n                saveScore(MODE.SAVE);\n            }\n        }\n    }\n    function personaliseGame() {\n         window.onmessage = function(e) {\n            var container = e.data,\n                data;\n            //TODO: Put restrictions somehow on which origin is accepted\n            console.log(\"ONMESSAGE EVENT received on Parent\");\n            if(container.msgType === MSG_TYPE.DATABASE_UPDATED) {\n                console.log('Received DATABASE_UDPATED.Killing Now');\n                if(container.mode === MODE.SAVE_KILL) {\n                    killGame();\n                } else if(container.mode === MODE.SAVE_KILL_RESTART) {\n                    killGame();\n                    main();\n                }\n            }\n            else if(container.msgType === MSG_TYPE.UPDATE_PAGE) {\n                data = container.data;\n                if(data.highestScore !== '-1') {\n                    gulp_counter_el.innerHTML = data.highestScore;\n                }\n                login_el.style.display = \"none\";\n                document.title = \"Hi \"+data.email+\"(\"+data.name+\")\";\n                if(data.uuid) {\n                    loggedIn = true;\n                }\n                console.log('KNOWN USER1'+data.uuid);\n            } else if(container.msgType === MSG_TYPE.INITIALIZE_HOST_PAGE) {\n                var uuid = container.data.uuid;\n                console.log('KNOWN USER'+uuid);\n                if(uuid) {\n                    loggedIn = true;\n                    login_el.style.display = \"none\";\n                } else {\n                    updateLoginButton();\n                }\n            }\n         };\n    }\n    function start() {\n        snake.state = STATES.INITIALISING,\n        saveCurrentCfg();\n        modifyCfg();\n        setupPlayground();\n        getDimensions();\n        makeInitialSnake(snake_body);\n        markPoint(snake_body);\n        addKeyListener();\n        personaliseGame();\n    }\n    start();\n})();(function main() {\n    \"use strict\";\n    var LEFT_KEY_CODE = 37,\n        UP_KEY_CODE = 38,\n        RIGHT_KEY_CODE = 39,\n        DOWN_KEY_CODE = 40,\n        ESCAPE_KEY_CODE = 27,\n        SPACE_KEY_CODE = 32,//TO PAUSE THE GAME\n        R_KEY_CODE = 82,//Restart\n        NO_OF_INITIAL_BODY_PARTS = 3,\n        POSITIVE_90_ROTATION = \"rotate(90deg)\",\n        NEGATIVE_90_ROTATION = \"rotate(-90deg)\",\n        NEGATIVE_180_ROTATION = \"rotate(-180deg)\",\n        ZERO_ROTATION = \"\",\n        BODY_PART_SIZE = 20, \n        SPEED = 60,\n        INCREASE_SIZE_BY = 1,\n        GULP_COUNTER_DIV_ID = 'snake_gulp_counter',\n        GULP_COUNTER_DIV_CLASS = 'snake_gulp_counter',\n        LAST_BODY_PART_SELECTOR = '#snake span:nth-last-child(1)',\n        SNAKE_FIGURE = '<svg xmlns = \"http://www.w3.org/2000/svg\" version=\"1.1\"><rect class=\"snake_figure\" id=\"snake_figure\" width=\"' + BODY_PART_SIZE + '\" height=\"' + BODY_PART_SIZE + '\"/></svg>',\n        PLAYGROUND_CLASS = 'snake_playground',\n        PLAYGROUND_ID = 'snake_playground',\n        SNAKE_BODY_CLASS = 'snake',\n        SNAKE_BODY_ID = 'snake',\n        SNAKE_BODY_PART_CLASS = 'snake_body_part',\n        SNAKE_BODY_PART_ID = 'snake_body_part',\n        GAME_STATE_CLASS = 'snake_state',\n        GAME_STATE_ID = 'snake_state',\n        GAME_STATE_HTML = '<b>PAUSED</b>',\n        CRASH_OPTIONS_CLASS = 'crash_options',\n        CRASH_OPTIONS_ID = 'crash_options',\n        CRASH_OPTIONS_HTML = \"Press <b><i>'r'</i></b> to Restart or <b><i>'Esc'</i></b> to Exit\",\n        IFRAME_ID = \"snake_iframe\",\n        IFRAME_SRC = \"http://php-hariombalhara.rhcloud.com/personalise.html\",\n        STATES = {\n            RUNNING: 0, \n            PAUSED: 1,\n            ENDED: 2, //Game has ended .But things are still there.\n            INITIALISING: 3,\n            DESTROYED: 4 //Games has ended and complete playground has been destroyed\n            },\n        body = document.body,\n        snake = window.snake = {},//Snake Namespace\n        point = snake.point = {},//Holds the position of the point.\n        orig_layout = snake.orig_layout = {},//It will hold the original style information for the page\n        key_queue = snake.key_queue = [],//Holds the keys to be processed\n        window_availWidth = -1,\n        window_availHeight = -1,\n        width = -1,\n        height = -1,\n        snake_playground = {},\n        snake_body = {},\n        state_of_game_el = {},\n        gulp_counter_el = {},\n        startover_max_counter = 0,\n        crash_options,\n        iframe;\n    function getIntPartFromStr(str) {\n        return parseInt(str, 10);\n    }\n    function isDestroyed() {\n        if (snake.state === STATES.DESTROYED) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function isEnded() {\n        if (snake.state === STATES.ENDED) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function copy_style(el, save_obj) {\n        var style = el.style,\n            obj_style = {},\n            i;\n        if (!save_obj.style) {\n            obj_style = save_obj.style = {};\n        } else {\n            obj_style = save_obj.style;\n        }\n        for (i in style) { //TODO:Need to be more specific cause style can have methods too.This is a very genric approach,can cause problem in future\n            obj_style[i] = style[i];\n        }\n    }\n    function toggle(boolvar)\n    {\n        if (typeof boolvar !== 'boolean') {\n            throw new Error('boolvar is not a bool');\n        }\n        if (boolvar === true)\n        {\n            boolvar = false;\n        } else {\n            boolvar = true;\n        }\n        return boolvar;\n    }\n    //Save the current style info in case something wrong happens or fore restoration\n    function saveCurrentLayout() {\n        var b = orig_layout.body = {};\n        b.style = {};\n        b.style.overflow = body.style.overflow;\n        b.style.margin = body.style.margin;\n        //copy_style(body, snake.orig_layout.body);\n    }\n    function modifyLayout() {\n        body.style.overflow = \"hidden\";\n        body.style.margin = \"0\";\n    }    \n    function moveStateTo(state) {\n        if (state === STATES.PAUSED) {\n            snake.state = state;\n            state_of_game_el.innerHTML = \"PAUSED\";\n            clearInterval(snake.interval);\n        } else if (state === STATES.ENDED) {\n            snake.state = state;\n            state_of_game_el.innerHTML = \"ENDED\";\n            clearInterval(snake.interval);\n        } else if (state == STATES.RUNNING) {\n            state_of_game_el.innerHTML = \"\";\n            snake.interval = setInterval(function() {simulateSnake(snake_body);}, SPEED);\n        }\n    }\n    function getDimensions() {\n        window_availWidth = snake_playground.offsetWidth;\n        window_availHeight = snake_playground.offsetHeight;\n        width = snake.width = Math.floor(window_availWidth-(window_availWidth%BODY_PART_SIZE));\n        height = snake.height = Math.floor(window_availHeight-(window_availHeight%BODY_PART_SIZE));\n    }\n    function appendChildWithInformation(child) {\n        var el = createSnakeElement(child);\n        this.appendChild(el);\n        return el;\n    }\n    function createSnakeElement(props) {\n        var el = document.createElement(props.tagName),\n            props_style=props.style;\n        if (props.className) {\n            el.setAttribute('class', props.className);\n        }\n        if (props.id) {\n            el.setAttribute('id', props.id);\n        }\n        if (props.innerHTML) {\n            el.innerHTML = props.innerHTML;\n        }\n        if ((typeof props_style) !== \"undefined\") {\n            if ((typeof props_style.left) !== \"undefined\") {\n                el.style.left = props.style.left;\n            }\n            if ((typeof props_style.top) !== \"undefined\") {\n                el.style.top = props.style.top;\n            }\n            if ((typeof props_style.height) !== \"undefined\") {\n                el.style.height = props.style.height;\n            }\n            if ((typeof props_style.width) !== \"undefined\") {\n                el.style.width = props.style.width;\n            }\n        }\n        el.appendChildWithInformation = appendChildWithInformation;\n        return el;\n    }\n    function insertFrame() {\n        iframe = document.createElement('iframe');\n        iframe.id = IFRAME_ID;\n        iframe.src = IFRAME_SRC;\n        snake_playground.appendChild(iframe);\n    }\n    function setupPlayground() {\n        snake_playground = createSnakeElement({\n            tagName: 'div',\n            className: PLAYGROUND_CLASS,\n            id: PLAYGROUND_ID,\n            style: {\n            height: \"100%\",\n            width: \"100%\"\n        }\n    });//Its the root element for the snake game\n        snake_body = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: SNAKE_BODY_CLASS,\n            id: SNAKE_BODY_ID,\n            style: {\n            }\n        });\n        gulp_counter_el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: GULP_COUNTER_DIV_CLASS,\n            id: GULP_COUNTER_DIV_ID,\n            innerHTML: '0'\n        });\n        state_of_game_el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: GAME_STATE_CLASS,\n            id: GAME_STATE_ID,\n            innerHTML: GAME_STATE_HTML\n        });\n        crash_options = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName: 'div',\n            className: CRASH_OPTIONS_CLASS,\n            id: CRASH_OPTIONS_ID,\n            innerHTML: CRASH_OPTIONS_HTML\n        });\n        //Finally append the snake playground to the body.\n        body.appendChild(snake_playground);\n        insertFrame();\n    }\n    function gulp(el, consume) {\n        var i;\n        if((typeof gulp.id) === \"undefined\") {\n            gulp.id=0;\n        }\n        if((typeof gulp.count) === \"undefined\") {\n            gulp.count=0;\n        }\n        if(consume === true) {\n            for (i = 0; i < INCREASE_SIZE_BY; i++) {\n                gulp.id+=1;\n                var offsetx=0;\n                var offsety=0;\n                var firstChild = el.childNodes[0];\n                var firstChild_style = firstChild.style;\n                var left = getIntPartFromStr(firstChild_style.left);\n                var top = getIntPartFromStr(firstChild_style.top);\n                var rotation = firstChild.rotation;\n                //The insertion philosophy is opposite to usual\n                if(rotation === NEGATIVE_180_ROTATION) {\n                    offsetx = BODY_PART_SIZE;\n                } else if(rotation === ZERO_ROTATION) {\n                    offsetx=-BODY_PART_SIZE;\n                } else if(rotation === POSITIVE_90_ROTATION) {\n                    offsety=-BODY_PART_SIZE;\n                } else if(rotation === NEGATIVE_90_ROTATION) {\n                    offsety = BODY_PART_SIZE;\n                }\n                if((offsetx === 0) && (offsety === 0)) {\n                    console.log(\"RAISE EXCEPTION HERE\");\n                }\n                var span = createSnakeElement({\n                    tagName: 'span',\n                    className: SNAKE_BODY_PART_CLASS,\n                    id: SNAKE_BODY_PART_ID+gulp.id,\n                    innerHTML: SNAKE_FIGURE,\n                    style: {\n                        left:left+offsetx+\"px\",\n                        top:top+offsety+\"px\"\n                    }\n                });\n                span.rotation = rotation;\n                el.insertBefore(span, el.childNodes[0]);\n            }\n            gulp.count+=1;\n            gulp_counter_el.innerHTML = gulp.count;\n        } else {\n            gulp.id+=1;\n            el.appendChildWithInformation.call(el, {\n                tagName:'span',\n                className:SNAKE_BODY_PART_CLASS,\n                id:SNAKE_BODY_PART_ID+gulp.id,\n                innerHTML:SNAKE_FIGURE,\n                style:{\n                    left:0,\n                    top:0\n                }\n            });\n        }\n    }\n    function makeInitialSnake(el) {\n        var i;\n        for (i = 0; i < NO_OF_INITIAL_BODY_PARTS; i++) {\n            gulp(el);\n            if(i >= 1 && (i <  NO_OF_INITIAL_BODY_PARTS)) {\n                el.childNodes[i].style.left=(getIntPartFromStr(el.childNodes[i].style.left)+(i*BODY_PART_SIZE))+\"px\";\n            }\n        }\n        snake.paused = true;\n    }\n    function restoreLayout() {\n        var b = orig_layout.body;\n        body.style.overflow = b.style.overflow;\n        body.style.margin = b.style.margin;\n    }\n    function markPoint(el) {\n        var x = -1,\n            y = -1,\n            count = 0,\n            len = el.childNodes.length;\n        while(true) {\n            var startover = false,\n                randx = Math.random(),\n                randy = Math.random(),\n                i;\n            x = (randx)*(getIntPartFromStr(width)-BODY_PART_SIZE);\n            y = (randy)*(getIntPartFromStr(height)-BODY_PART_SIZE);\n            x = x-(x%BODY_PART_SIZE);\n            y = y-(y%BODY_PART_SIZE);\n            for(i = 0; i < len-1; i++) {\n                var child = el.childNodes[i],\n                    child_style = child.style,\n                    top = child_style.top,\n                    left = child_style.left;\n                if((top === (y + \"px\")) && (left === (x + \"px\"))) {\n                    startover = true;\n                    if(startover_max_counter < count) {\n                        startover_max_counter = count;\n                        console.log(\"Startovercount highest value=\", startover_max_counter);\n                    }\n                    break;\n                }\n            }\n            if(!startover) {\n                break;\n            } else {\n                count++;\n            }\n        }\n        point.el = snake_playground.appendChildWithInformation.call(snake_playground, {\n            tagName:'div',\n            className:'snake_point',\n            id:'snake_point',\n            innerHTML:SNAKE_FIGURE,\n            style:{\n                left:x+\"px\",\n                top:y+\"px\"\n            }\n        });\n        //Store the position of the point in snake namespace for easy accessibilty\n        point.x = x;\n        point.y = y;\n    }\n    function append(keyCode) {\n        //FOR NOW ONLY THE LAST ELEMENT of QUEUE IS CONSIDERED\n        if(key_queue.length === 1) {\n            key_queue.shift();\n        }\n        key_queue.push(keyCode);\n    }\n    function addKeyListener() {\n        document.addEventListener(\"keydown\", keyEventListener, true);\n    }\n    function removeKeyListener() {\n        document.removeEventListener(\"keydown\", keyEventListener, true);\n    }\n    function freeze() {\n        clearInterval(snake.interval);\n        removeKeyListener();\n    }\n    function killGame() {\n        var script = document.getElementById('snake_script');\n        freeze();\n        try {\n            if(snake_playground) {\n                body.removeChild(snake_playground);\n            }\n        }\n        catch(e) {\n            console.log('Exception:', \"Caller is =\"+killGame.caller, \"ParentNode=\"+snake_playground.parentNode, \"Node=\"+snake_playground);\n        }\n        restoreLayout();\n        if(script)\n        document.getElementsByTagName('head')[0].removeChild(script);\n    }\n    function restartGame() {\n        killGame();\n        main();\n    }\n    function crashSnake() {\n        if(isDestroyed() || (snake.state === STATES.ENDED)) {\n            console.log('Crash Snake-STATE:',snake.state);\n            return;\n        }\n        crash_options.style.display = \"block\";\n        moveStateTo(STATES.ENDED)\n    }\n    function checkUpCrash(last_style) {\n        if((getIntPartFromStr(last_style.top)) < 0) {\n            crashSnake();\n        }\n    }\n    function checkLeftCrash(last_style) {\n        if((getIntPartFromStr(last_style.left)) < 0) {\n            crashSnake();\n        }\n    }\n    function checkRightCrash(last_style, offset) {\n        if((getIntPartFromStr(last_style.left)+offset) > width) {\n            crashSnake();\n        }\n    }\n    function checkDownCrash(last_style, offset) {\n        if((getIntPartFromStr(last_style.top)+offset) > height) {\n            crashSnake();\n        }\n    }\n    function processGeneral(element, distance, leave_last) {\n        //TODO: make a copy of node list as traversing it is costly.\n        var len = element.childNodes.length,\n            up_to = len,\n            i;\n        if(leave_last) {\n            up_to = len-1;\n        }\n        for(i = 0; i < up_to; i++) {\n            var child = element.childNodes[i],\n                child_style = child.style,\n                rotation,\n                rotation_flag = false,\n                lookahead_rotation_flag,\n                left_coordinate,\n                top_coordinate;\n            child.rotation=((typeof child.rotation) === \"undefined\")?ZERO_ROTATION:child.rotation;\n            rotation = child.rotation;            \n            if(child.rotation === POSITIVE_90_ROTATION || child.rotation === NEGATIVE_90_ROTATION) {\n                rotation_flag = true;\n            }\n            lookahead_rotation_flag=-1;\n            left_coordinate = getIntPartFromStr(child_style.left);\n            top_coordinate = getIntPartFromStr(child_style.top);\n            if(i+1 < len) {\n                if(element.childNodes[i+1].rotation === POSITIVE_90_ROTATION || element.childNodes[i+1].rotation === NEGATIVE_90_ROTATION) {\n                    lookahead_rotation_flag = true;\n                }\n                if(element.childNodes[i+1].rotation === ZERO_ROTATION || element.childNodes[i+1].rotation === NEGATIVE_180_ROTATION) {\n                    lookahead_rotation_flag = false;\n                }\n            }\n            if(((typeof rotation_flag) === \"undefined\") || (rotation_flag === false)) {\n                child.isRotated = false;\n                if(((typeof lookahead_rotation_flag) !== \"undefined\") && (lookahead_rotation_flag === true)) {\n                    child.isRotated = true;\n                    child.rotation = element.childNodes[i+1].rotation;\n                    //Simulate rotation\n                    if(child.rotation === NEGATIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate-(distance)) + \"px\";\n                    }\n                    if(child.rotation === POSITIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate+(distance)) + \"px\";\n                    }\n                } else {\n                    if(rotation === ZERO_ROTATION) {\n                        child_style.left = (left_coordinate+(distance)) + \"px\";\n                    } else if(rotation === NEGATIVE_180_ROTATION) {\n                        child_style.left = (left_coordinate-(distance)) + \"px\";\n                    }\n                }\n            }\n            else {//rotation flag is true\n                if(((typeof lookahead_rotation_flag) === \"undefined\") || (lookahead_rotation_flag === false)) {\n                    child.isRotated = false;\n                    child.rotation = element.childNodes[i+1].rotation;\n                    //Simulate rotation\n                    if(child.rotation === ZERO_ROTATION) {\n                        child_style.left = (left_coordinate + (distance)) + \"px\";\n                    }\n                    if(child.rotation === NEGATIVE_180_ROTATION) {\n                        child_style.left = (left_coordinate-(distance))+\"px\";\n                    }\n                }\n                else\n                {\n                    if(rotation === NEGATIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate-(distance))+'px';\n                    }\n                    else if(rotation === POSITIVE_90_ROTATION) {\n                        child_style.top = (top_coordinate+(distance))+'px';\n                    }\n                }\n            }\n        }\n    }\n    function checkOverlap(el) {\n        //TODO:copy childnodes to an array cause domenodes processing is costly\n        var last = body.querySelector(LAST_BODY_PART_SELECTOR),\n            last_style = last.style,\n            last_style_top = last_style.top,\n            last_style_left = last_style.left,\n            len = el.childNodes.length,\n            i;\n        for(i = 0; i < len-1; i++) {\n            var child = el.childNodes[i],\n                child_style = child.style,\n                top = child_style.top,\n                left = child_style.left;\n            if((top === last_style_top) && (left === last_style_left)) {\n                crashSnake();\n            }\n        }\n    }\n    function tryGulp(el) {\n        var last = body.querySelector(LAST_BODY_PART_SELECTOR);\n        var last_style = last.style;\n        var last_style_top = last_style.top;\n        var last_style_left = last_style.left;\n        if(((snake.point.x+\"px\") === last_style_left) && ((snake.point.y+\"px\") === last_style_top)) {\n            snake_playground.removeChild(point.el);\n            gulp(el, true);\n            markPoint(el);\n        }\n    }\n    function processDownKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var top_coordinate = getIntPartFromStr(child_style.top);\n        var leave_last = false;\n        if((rotation === ZERO_ROTATION) || (rotation === NEGATIVE_180_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.top = (top_coordinate + (distance)) + \"px\";\n            element.childNodes[key].rotation = POSITIVE_90_ROTATION;\n        }\n    }\n    function processUpKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var top_coordinate = getIntPartFromStr(child_style.top);\n        var leave_last = false;\n        if((rotation === ZERO_ROTATION) || (rotation === NEGATIVE_180_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.top = (top_coordinate - (distance)) + \"px\";\n            element.childNodes[key].rotation = NEGATIVE_90_ROTATION;\n        }\n    }\n    function processRightKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var left_coordinate = getIntPartFromStr(child_style.left);\n        var leave_last = false;\n        if((rotation === POSITIVE_90_ROTATION) || (rotation === NEGATIVE_90_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.left = (left_coordinate + (distance)) + \"px\";\n            element.childNodes[key].rotation = ZERO_ROTATION;\n        }\n    }\n    function processLeftKey(element, distance) {\n        var children = element.childNodes;\n        var key = children.length-1;\n        var rotation = children[key].rotation;\n        var child_style = children[key].style;\n        var left_coordinate = getIntPartFromStr(child_style.left);\n        var leave_last = false;\n        if((rotation === POSITIVE_90_ROTATION) || (rotation === NEGATIVE_90_ROTATION)) {\n            leave_last = true;\n            processGeneral(element, distance, leave_last);\n            child_style.left = (left_coordinate-(distance))+\"px\";\n            element.childNodes[key].rotation = NEGATIVE_180_ROTATION;\n        }\n    }\n    function processKeyEvent(el, keyCode) {\n        var no_of_child_nodes = el.childNodes.length;\n        var rotation = {};\n        rotation.value = el.childNodes[(no_of_child_nodes-1)].rotation;\n        el.childNodes[no_of_child_nodes-1].rotation = rotation.value = (typeof rotation.value === \"undefined\")?ZERO_ROTATION: rotation.value;\n        rotation.isNeg90 = (rotation.value === NEGATIVE_90_ROTATION );\n        rotation.isPos90 = (rotation.value === POSITIVE_90_ROTATION );\n        rotation.isNeg180=(rotation.value === NEGATIVE_180_ROTATION );\n        rotation.isZero = (rotation.value === ZERO_ROTATION );\n        var move_distance = BODY_PART_SIZE;\n        var last = document.body.querySelector(LAST_BODY_PART_SELECTOR);\n        var last_style = last.style;\n        var offset = BODY_PART_SIZE;\n        var isItTheExpectedKey = true;\n        switch(keyCode) {\n            case LEFT_KEY_CODE:\n                if(rotation.isNeg90 || rotation.isPos90 || rotation.isNeg180) {\n                    processLeftKey(el, move_distance);\n                    checkLeftCrash(last_style);\n                }\n                break;\n            case UP_KEY_CODE:\n                if(rotation.isNeg90 ||rotation.isZero || rotation.isNeg180) {\n                    processUpKey(el, move_distance);\n                    checkUpCrash(last_style);\n                }\n                break;\n            case RIGHT_KEY_CODE:\n                if(rotation.isPos90 || rotation.isZero || rotation.isNeg90) {\n                    processRightKey(el, move_distance);\n                    checkRightCrash(last_style, offset);\n                }\n                break;\n            case DOWN_KEY_CODE:\n                if(rotation.isPos90 || rotation.isZero || rotation.isNeg180) {\n                    processDownKey(el, move_distance);\n                    checkDownCrash(last_style, offset);\n                }\n                break;\n            default:\n                isItTheExpectedKey = false;\n                alert('Unexpected key');\n        }\n        if(isItTheExpectedKey) {\n            tryGulp(el);\n        }\n    }\n    function simulateSnake(el) {\n        var queue = key_queue;\n        var len = queue.length;\n        getDimensions(); //Get updated dimensions alwasy\n        if(len === 0) {\n            processGeneral(el, BODY_PART_SIZE);\n            //Not pressing any key means snake is moving in direction of last body_part\n            var last = body.querySelector(LAST_BODY_PART_SELECTOR);\n            var rotation = last.rotation;\n            var last_style = last.style;\n            // console.log(\"STYLE\", last_style)\n            var offset = BODY_PART_SIZE;//Need to adjust it\n            if(rotation === NEGATIVE_180_ROTATION) {\n                checkLeftCrash(last_style);\n            }\n            else if(rotation === ZERO_ROTATION) {\n                checkRightCrash(last_style, offset);\n            }\n            else if(rotation === POSITIVE_90_ROTATION) {\n                checkDownCrash(last_style, offset);\n            }\n            else if(rotation === NEGATIVE_90_ROTATION) {\n                checkUpCrash(last_style);\n            }\n            if(isDestroyed()) {\n                return;\n            }\n            checkOverlap(el);\n            tryGulp(el);\n        }\n        else {\n            processKeyEvent(el, queue.pop());\n        }\n    }\n\n    function postToHostingSite(container) {\n        //TODO:Put Restriction here for target ORigin\n        console.log('POSTING MESSAGE to Game Host'+iframe);\n        iframe.contentWindow.postMessage(container,'*');\n    }\n    function saveScore() {\n        var container = {\n            score:gulp_counter_el.innerHTML\n        }\n        postToHostingSite(container);\n    }\n    function keyEventListener(e) {\n        if(e.keyCode === LEFT_KEY_CODE ||e.keyCode === DOWN_KEY_CODE ||e.keyCode === UP_KEY_CODE ||e.keyCode === RIGHT_KEY_CODE ) {\n            e.preventDefault();\n            e.stopPropagation();\n            if(!isDestroyed() && !isEnded()) {\n                append(e.keyCode);\n            }\n        } else {\n            if(e.keyCode === ESCAPE_KEY_CODE) {\n                if(isDestroyed()) {\n                    return;\n                }\n                e.preventDefault();\n                e.stopPropagation();\n                saveScore();\n                killGame();\n            } else if(e.keyCode === SPACE_KEY_CODE) {\n                e.preventDefault();\n                e.stopPropagation();\n                if(isDestroyed() || isEnded()) {\n                    return;\n                }\n                if(snake.paused === true) {\n                    moveStateTo(STATES.RUNNING);\n                } else {\n                    moveStateTo(STATES.PAUSED);\n                }\n                snake.paused = toggle(snake.paused);\n            } else if(e.keyCode === R_KEY_CODE) {\n                e.preventDefault();\n                e.stopPropagation();\n                restartGame();\n            }\n        }\n    }\n    \n    \n    function personaliseGame() {\n         window.onmessage = function(e) {\n            //TODO: Put restrictions somehow on which origin is accepted\n            console.log(\"ONMESSAGE EVENT\");\n            if(e.data.score !== -1)\n            gulp_counter_el.innerHTML = e.data.score\n            document.title =\"Hi \"+e.data.email;\n        }\n    }\n    function start() {\n        snake.state = STATES.INITIALISING,\n        saveCurrentLayout();\n        modifyLayout();\n        setupPlayground();\n        getDimensions();\n        makeInitialSnake(snake_body);\n        markPoint(snake_body);\n        addKeyListener();\n        personaliseGame();\n    }\n    start();\n})();"]],"start1":34871,"start2":34871,"length1":58744,"length2":4}]],"length":34875,"saved":false}
{"ts":1342331989679,"patch":[[{"diffs":[[0,"(0.04 * "],[-1,"common"],[1,"window_availWidth"],[0,") ;\n    "]],"start1":6194,"start2":6194,"length1":22,"length2":33}]],"length":34886,"saved":false}
{"ts":1342332014557,"patch":[[{"diffs":[[0,"  }\n"],[-1,"    function getDimensions_1() {\n        var common;\n        /*window_availWidth = snake_playground.offsetWidth;\n        window_availHeight = snake_playground.offsetHeight;\n        if(window_availHeight > window_availWidth) {\n            common = window_availHeight = window_availWidth;\n        } else {\n            common = window_availWidth = window_availHeight;\n        }*/\n        common = PLAYGROUND_DIMENSION;\n        \n        width = height = snake.width = snake.height = Math.floor(common-(common%BODY_PART_SIZE));\n    }\n    \n"],[0,"    "]],"start1":5473,"start2":5473,"length1":542,"length2":8}]],"length":34352,"saved":false}
